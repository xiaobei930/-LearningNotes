{"book/technology/linux/Special-lecture/操作系统入门.html":{"url":"book/technology/linux/Special-lecture/操作系统入门.html","title":"操作系统入门","keywords":"","body":"操作系统入门 Linux 是一套免费使用和自由传播的类 UNIX 操作系统，是一个基于 POSIX 移植操作系统接口（Portable Operating System Interface of UNIX，POSIX）和 UNIX 的多用户、多任务、支持多线程和多 CPU 的操作系统。 目前被广泛使用于企业服务器、WEB 网站平台、大数据、虚拟化、Android、超级计算机等领域，未来 Linux 将应用各行各业，例如云计算、物联网、人工智能等。 windows 操作系统简介 为什么要学习 Windows 操作系统呢，了解 Windows 系统结构，可以让我们快速学习 Linux 操作系统，通过对比学习的方法，我们可以更快的学会 Linux。 计算机硬件组成包括：CPU、内存、网卡、硬盘、DVD 光驱、电源、主板、显示器、鼠标等设备，计算机硬件是不能直接被人使用的，需要在其上安装各种操作系统，安装完操作系统，并安装驱动程序，方可进行操作、办公、上网冲浪等。 驱动程序主要指的是设备驱动程序（Device Driver），是一种可以使计算机系统和设备通信的特殊程序，相当于硬件的接口，操作系统只有通过这个接口，才能控制硬件设备，进行资源调度。 Windows 操作系统主要以窗口形式对用户展示，操作系统须安装在硬盘上，安装系统之前需对硬盘进行分区并格式化，默认 Windows 操作系统安装在 C 盘分区，D 盘分区用于存放数据文件。 通俗的讲，安装操作系统时，需要对磁盘进行格式化，格式化需要指定格式化的类型，告诉操作系统如何去管理磁盘空间，文件如何存放，如何查找及调用。操作系统不知道怎么存放文件以及文件结构，文件系统概念就诞生了。 文件系统是操作系统用于明确磁盘或分区上文件的方法和数据存储结构，文件系统由三部分组成：与文件管理有关软件、被管理文件以及实施文件管理所需数据结构。 Windows 操作系统，文件系统类型一般有 FAT、FAT16、FAT32、NTFS 等，不同的文件系统类型，有不同的特性，例如 NTFS 文件系统类型支持文件及文件夹安全设置，而 FAT32 文件系统类型不支持，NTFS 支持单文件最多为单个磁盘分区的容量大小 2T，而 FAT32 单个最大文件不能超过 4GB。 Windows 操作系统从设计层面来讲，主要用来管理电脑硬件与软件资源的程序，大致包括五个方面的管理功能:进程与处理机管理、作业管理、存储管理、设备管理、文件管理。Windwos 操作系统从个人使用角度来讲，主要用于个人电脑办公、软件安装、上网冲浪、游戏、数据分析、数据存储等功能。 linux linux 操作系统简介 Linux 操作系统是基于 UNIX 以网络为核心的设计思想，是一个性能稳定的多用户网络操作系统，Linux 能运行各种工具软件、应用程序及网络协议，它支持安装在 32 位和 64 位 CPU 硬件上。 通常的讲，Linux 这个词本身只表示 Linux 内核，但是人们已经习惯用 Linux 来形容整个基于 Linux 内核的操作系统，并且是一种使用 GNU 通用公共许可证（GNU General Public License，GPL）工程各种工具和数据库的操作系统。 GNU 是“GNU is Not Unix”，UNIX 是一种广泛使用的商业操作系统，由于 GNU 将要实现以 UNIX 系统的接口标准，因此 GNU 计划可以分别开发不同的操作系统部件，并且采用了部分当时已经可自由使用的软件。 为了保证 GNU 软件可以自由地“使用、复制、修改和发布”，所有的 GNU 软件都在一份禁止其他人添加任何限制的情况下授权所有权利给任何人的协议条款里，我们把这个条款称之为 GNU 通用公共许可证（GNU General Public License，GPL）。 1991 年的 10 月 5 日，Linux 创始人 Linus Torvalds 在 comp.os.minix 新闻组上发布消息，正式向外宣布 Linux 内核的诞生，1994 年 3 月 Linux 1.0 发布，代码量 17 万行，当时是完全按照自由免费的协议发布，随后正式采用 GPL 协议，目前 GPL 协议版本包括：GPLv1、GPLv2、GPLv3 以及未来的 GPLv4、GPLv5 等。 1.3 Linux 操作系统优点 随着 IT 产业的不断发展，Linux 操作系统应用领域越来越广泛，尤其是近年来 Linux 在服务器领域飞速的发展，主要得益于 Linux 操作系统具备的如下优点： 开源免费 系统迭代更新 系统性能稳定 安全性高 多任务，多用户 耗资源少 内核小 应用领域广泛 使用及入门容易 linux 运维发展前景及就业形势 权威部门统计，未来几年内我国软件行业的从业机会十分庞大，中国每年对 IT 软件人才的需求将达到 200 万人左右。而对于 Linux 专业人才的就业前景，更是广阔；据悉在未来 5-10 年内 Linux 专业人才的需求将达到 150 万，尤其是有 Linux 行业经验的，资深的 Linux 工程师非常缺乏，薪资也非常诱人，平均月薪 15000-25000，甚至更高，Linux 行业薪资如下图 硬盘分区简介 学习 Windows、Linux 操作系统，必然要了解硬盘设备，硬盘是电脑主要的存储媒介之一，硬盘要能够安装系统或者存放数据，必须进行分区和格式化，Windows 系统常见分区有三种：主磁盘分区、扩展磁盘分区、逻辑磁盘分区。 一块硬盘设备，主分区至少有 1 个，最多 4 个，扩展分区可以为 0，最多 1 个，且主分区+扩展分区总数不能超过 4 个，逻辑分区可以有若干个。在 Windows 下激活的主分区是硬盘的启动分区，他是独立的，也是硬盘的第一个分区，通常就是我们所说的 C 盘系统分区。 扩展分区是不能直接用的，他是以逻辑分区的方式来使用的，扩展分区可分成若干逻辑分区。他们的关系是包含的关系，所有的逻辑分区都是扩展分区的一部分。 在 Windows 系统安装时，硬盘驱动器是通过磁盘 0,磁盘 1 来显示,其中磁盘 0 表示第一块硬盘,磁盘 1 表示第二块硬盘,然后在第一块硬盘磁盘 0 上进行分区，最多不能超过 4 个主分区,分区为 C、D、E、F。 硬盘接口是硬盘与主机系统间的连接部件，作用是在硬盘缓存和主机内存之间传输数据。不同的硬盘接口决定着硬盘与计算机之间的连接速度，在整个系统中，硬盘接口的优劣直接影响着程序运行快慢和系统性能好坏，常见的硬盘接口类型为：IDE（Integrated Drive Electronics）、SATA（Serial Advanced Technology Attachment）、SCSI（Small Computer System Interface）、SAS（Serial Attached SCSI）和光纤通道等。 IDE 接口硬盘多用于家用，部分也应用于传统服务器，SCSI、SAS 接口的硬盘则主要应用于服务器市场，而光纤通道用于高端服务器上，SATA 主要用于个人家庭办公电脑及低端服务器。 在 Linux 操作系统中，读者可以看到硬盘驱动器的第一块 IDE 硬盘接口的硬盘设备为 hda，或者 SATA 硬盘接口的硬盘设备为 sda，主分区编号为 hda1-4 或者 sda1-4，逻辑分区从 5 开始。如果有第二块硬盘，主分区编号为 hdb1-4 或者 sdb1-4。 不管是 Windows 还是 Linux 操作系统，硬盘的总容量=主分区的容量+扩展分区的容量，而扩展分区的容量=各个逻辑分区的容量之和。主分区也可成为“引导分区”，会被操作系统和主板认定为这个硬盘的第一个分区，所以 C 盘永远都是排在所有磁盘分区的第一的位置上。 MBR（Master Boot Record）和 GPT（GUID Partition Table）是在磁盘上存储分区信息的两种不同方式。这些分区信息包含了分区从哪里开始的信息，这样操作系统才知道哪个扇区是属于哪个分区的，以及哪个分区是可以启动操作系统的。 在磁盘上创建分区时，必须选择 MBR 或者 GPT，默认是 MBR，也可以通过其他方式修改为 GPT 方式。MBR 分区的硬盘最多支持 4 个主分区，如果想支持更多主分区，可以考虑使用 GPT 格式分区。 学好 linux 的方法 系统安装是初学者的门槛，系统安装完毕后，很多初学者不知道该如何学习，不知道如何快速进阶，下面作者总结了菜鸟学好 Linux 技能的大绝招： 需熟练掌握 Linux 系统管理必备命令，命令包括：cd、ls、pwd、clear、chmod、chown、chattr、useradd、userdel、groupadd、vi、vim、cat、more、less、mv、cp、rm、rmdir、touch、ifconfig、ip addr、ping、route、echo、wc、expr、bc、ln、head、tail、who、hostname、top、df、du、netstat、ss、kill、alias、man、tar、zip、unzip、jar、fdisk、free、uptime、lsof、lsmod、lsattr、dd、date、crontab、ps、find、awk、sed、grep、sort、uniq 等，每个命令至少练习 30 遍，逐步掌握每个命令的用法及应用场景； 熟练构建 Linux 下常见服务（DHCP、SAMBA、DNS、Apache、MySQL、Nginx、Zabbix、Squid、Varnish、LVS、Keepalived、ELK、MQ、Zookeeper、Docker、Openstack、Hbase、Mongodb、Redis 等，遇到问题先思考，没有头绪可以借助百度、Google 搜索引擎，问题解决后，将解决问题的步骤总结并形成文档； 理解操作系统的每个命令，每个服务的用途，为什么要配置这个服务，为什么需要调整该参数，只有带着目标去学习才能更快的成长，才能让你去发掘更多新知识； 熟练搭建 Linux 系统上各种服务之后，需要理解每个服务的完整配置和优化，可以拓展思维。例如 LAMP 所有服务放在一台机器上，能否分开放在多台服务器以平衡压力呢，该如何去构建和部署呢？一台物理机构建 Docker 虚拟化，如果是 100 台、1000 台如何去实施呢，会遇到哪些问题呢； Shell 是 Linux 最经典的命令解释器，Shell 脚本可以实现自动化运维，平时多练习 Shell 脚本编程，每个 Shell 脚本多练习几遍，从中吸取关键的参数、语法，不断的练习，不断的提高； 建立个人学习博客，把平时工作、学习中的知识都记录到博客，一方面可以供别人参考，另一方面可以提高自己文档编写及总结的能力； 学习 Linux 技术是一个长期的过程，一定要坚持，遇到各种错误、问题可以借助百度、Google 搜索引擎，如果解决不了，可以请教同学、朋友及你的老师； 通过以上步骤的学习方法，不断进步，如果想达到高级、资深大牛级别，还需要进一步深入学习 WEB 集群架构、网站负载均衡、网站架构优化、自动化运维、运维开发、虚拟化等知识； 多练习才是硬道理，实践出真知。 linux 系统管理 操作系统启动概念 不管是 Windows 还是 Linux 操作系统，底层设备一般均为物理硬件，操作系统启动之前会对硬件进行检测，然后硬盘引导启动操作系统，如下为操作系统启动相关的各个概念： BIOS 基本输入输出系统（Basic Input Output System，BIOS）是一组固化到计算机主板上的只读内存镜像（Read Only Memory image，ROM）芯片上的程序，它保存着计算机最重要的基本输入输出的程序、系统设置信息、开机后自检程序和系统自启动程序。主要功能是为计算机提供最底层的、最直接的硬件设置和控制。 MBR 全新硬盘在使用之前必须进行分区格式化，硬盘分区初始化的格式主要由两种，分别是：MBR 格式和 GPT 格式。 如果使用 MBR 格式，操作系统将创建主引导记录扇区（Main Boot Record，MBR），MBR 位于整块硬盘的 0 磁道 0 柱面 1 扇区，主要功能是操作系统对磁盘进行读写时，判断分区的合法性以及分区引导信息的定位。 主引导扇区总共为 512 字节，MBR 只占用了其中的 446 个字节，另外的 64 个字节为硬盘分区表 (Disk Partition Table，DPT)，最后两个字节“55，AA”是分区的结束标志。 在 MBR 硬盘中，硬盘分区信息直接存储于主引导记录（MBR）中，同时主引导记录还存储着系统的引导程序 MBR 是计算机启动最先执行的硬盘上的程序，只有 512 字节大小，所以不能载入操作系统的核心，只能先载入一个可以载入计算机核心的程序，我们称之为引导程序。 因为 MBR 分区标准决定了 MBR 只支持在 2TB 以下的硬盘，对于后面的多余空间只能浪费。为了支持能使用大于 2T 硬盘空间，微软和英特尔公司在可扩展固件接口(Extensible Firmware Interface，EFI)方案中开发了全局唯一的标识符（Globally unique identifier，GUID），进而全面支持大于 2T 硬盘空间在企业中使用。 GPT 全局唯一的标识符（Globally unique identifier，GUID），正逐渐取代 MBR 成为新标准。它和统一的可扩展固件接口 (Unified Extensible Firmware Interface,UEFI)相辅相成。 UEFI 用于取代老旧的 BIOS，而 GPT 则取代老旧的 MBR。之所以称为“GUID 分区表”，是因为驱动器上的每个分区都有一个全局唯一的标识符。 在 GPT 硬盘中，分区表的位置信息储存在 GPT 头中。出于兼容性考虑，第一个扇区同样有一个与 MBR 类似的标记，叫做受保护的主引导记录（Protected Main Boot Record，PMBR）。 PMBR 的作用是当使用不支持 GPT 的分区工具时，整个硬盘将显示为一个受保护的分区，以防止分区表及硬盘数据遭到破坏，而其中存储的内容和 MBR 一样，之后才是 GPT 头。 GPT 优点支持 2T 以上磁盘，如果使用 Fdisk 分区，最大只能建立 2TB 大小的分区，创建大于 2TB 的分区，需使用 parted，同时必须使用 64 位操作系统，Mac、Linux 系统都能支持 GPT 分区格式，Windows 7/8 64bit、Windows Server 2008 64bit 支持 GPT. GRUB GNU 项目的多操作系统启动程序（GRand Unified Bootloader，GRUB），可以支持多操作系统的引导，它允许用户可以在计算机内同时拥有多个操作系统，并在计算机启动时选择希望运行的操作系统。 GRUB 可用于选择操作系统分区上的不同内核，也可用于向这些内核传递启动参数。它是一个多重操作系统启动管理器。用来引导不同系统，如 Windows，Linux。Linux 常见的引导程序包括：LILO、GRUB、GRUB2，CentOS 7 Linux 默认使用 GRUB2 引导程序，引导系统启动。 GRUB2 是基于 GRUB 开发成更加安全强大的多系统引导程序，最新 Linux 发行版都是使用 GRUB2 作为引导程序。同时 GRUB2 采用了模块化设计，使得 GRUB2 核心更加精炼，使用更加灵活，同时也就不需要像 GRUB 分为 stage1,stage1.5,stage2 三个阶段。 Linux 操作系统启动流程 加载 BIOS 计算机电源加电质检，首先加载基本输入输出系统（Basic Input Output System，BIOS），BIOS 中包含硬件 CPU、内存、硬盘等相关信息，包含设备启动顺序信息、硬盘信息、内存信息、时钟信息、即插即用（Plug-and-Play，PNP）特性等。加载完 BIOS 信息，计算机将根据顺序进行启动。 读取 MBR 读取完 BIOS 信息，计算机将会查找 BIOS 所指定的硬盘 MBR 引导扇区，将其内容复制到 0x7c00 地址所在的物理内存中。被复制到物理内存的内容是 Boot Loader，然后进行引导。 GRUB 引导 GRUB 启动引导器是计算机启动过程中运行的第一个软件程序，当计算机读取内存中的 GRUB 配置信息后，会根据其配置信息来启动硬盘中不同的操作系统。 加载 kernel 计算机读取内存映像，并进行解压缩操作，屏幕一般会输出“Uncompressing Linux”的提示，当解压缩内核完成后，屏幕输出“OK, booting the kernel”。系统将解压后的内核放置在内存之中，并调用 start_kernel()函数来启动一系列的初始化函数并初始化各种设备，完成 Linux 核心环境的建立。 设定 inittab 运行等级 内核加载完毕，会启动 Linux 操作系统第一个守护进程 init，然后通过该进程读取/etc/inittab 文件，/etc/inittab 文件的作用是设定 Linux 的运行等级，Linux 常见运行级别如下： 0：关机模式； 1：单用户模式； 2：无网络支持的多用户模式； 3：字符界面多用户模式； 4：保留，未使用模式； 5：图像界面多用户模式； 6：重新引导系统，重启模式。 加载 rc.sysinit 读取完运行级别，Linux 系统执行的第一个用户层文件/etc/rc.d/rc.sysinit，该文件功能包括：设定 PATH 运行变量、设定网络配置、启动 swap 分区、设定/proc、系统函数、配置 Selinux 等。 加载内核模块 读取/etc/modules.conf 文件及/etc/modules.d 目录下的文件来加载系统内核模块。该模块文件，可以后期添加或者修改及删除。 启动运行级别程序 根据之前读取的运行级别，操作系统会运行 rc0.d 到 rc6.d 中的相应的脚本程序，来完成相应的初始化工作和启动相应的服务。其中以 S 开头表示系统即将启动的程序，如果以 K 开头，则代表停止该服务。S 和 K 后紧跟的数字为启动顺序编号。 读取 rc.local 文件 操作系统启动完相应服务之后，会读取执行/etc/rc.d/rc.local 文件，可以将需要开机启动的任务加入到该文件末尾，系统会逐行去执行并启动相应命令 执行/bin/login 程序 执行/bin/login 程序，启动到系统登录界面，操作系统等待用户输入用户名和密码，即可登录到 Shell 终端，如图 3-7 所示，输入用户名、密码即可登录 Linux 操作系统，至此 Linux 操作系统完整流程启动完毕。 Linux 系统配置 IP Linux 系统配置 DNS centos7 重置密码 Linux 系统目录功能 Linux 主要树结构目录包括：/、/root、/home、/usr、/bin、/tmp、/sbin、/proc、/boot 等 / 根目录； /bin 存放必要的命令； /boot 存放内核以及启动所需的文件； /dev 存放硬件设备文件； /etc 存放系统配置文件； /home 普通用户的宿主目录，用户数据存放在其主目录中； /lib|lib64 存放必要的运行库； /mnt 存放临时的映射文件系统，通常用来挂载使用； /proc 存放存储进程和系统信息； /root 超级用户的主目录； /sbin 存放系统管理程序； /tmp 存放临时文件； /usr 存放应用程序，命令程序文件、程序库、手册和其它文档； /var 系统默认日志存放目录。 By xiaobei，使用知识共享 署名-相同方式共享 4.0协议发布            此页面修订于： 2020-08-15 09:39:51 "},"book/technology/linux/Special-lecture/linux介绍及安装.html":{"url":"book/technology/linux/Special-lecture/linux介绍及安装.html","title":"linux 介绍及安装","keywords":"","body":"linux 介绍及安装 什么是云计算 云计算是分布式计算的一种，通过网络云将多个服务器组成一个超级计算系统， 以此来解决庞大的计算任务。 什么是云计算服务 云服务就是通过网络向用户提供一种按需付费的交易模式。 云服务一般可分为三个层面，分别是： IaaS 基础设施即服务 PaaS 平台即服务 SaaS 软件即服务 准备软件 vmware 虚拟机 centos7.x 镜像 xshell 或者 crt 有道云笔记或者 typora Linux 操作系统简介 Linux 操作系统是基于 UNIX 以网络为核心的设计思想，是一个性能稳定的多用户操作系统，Linux 能运行各种工具软件、应用程序及网络协议，它支持安装在 32 位和 64 位 CPU 硬件上。 linux 即 linus's unix,在 1991 年的 10 月 5 日，还在读大学的 Linus Torvalds 写出了 linux 内核。 Linux 操作系统应用领域越来越广泛，尤其是近年来 Linux 在服务器领域飞速的发展，主要得益于 Linux 操作系统具备的如下优点： 开源、免费； 系统迭代更新； 系统性能稳定； 安全性高； 内核小； 应用领域广泛； 使用及入门容易。 Linux 操作系统发行版 Linux 操作系统主流发行版本包括：Red Hat Linux、CentOS、Ubuntu、SUSE Linux、Fedora Linux 等 Red Hat Linux Red Hat Linux 1994 年创立，是最早的 Linux 发行版本之一，同时也是最著名的 Linux 版本，Red Hat Linux 已经创造了自己的品牌，也是读者经常听到的“红帽操作系统”。2018 年 10 月份 IBM 正式宣布以 340 亿美元收购红帽。 CentOS 社区企业版操作系统（Community Enterprise Operating System，CentOS）是 Linux 发行版之一，它是来自于 Red Hat Enterprise Linux 依照开放源代码所编译而成。由于出自同样的源代码，因此有些要求高度稳定性的服务器以 CentOS 替代商业版的 Red Hat Enterprise Linux 使用。 CentOS 于 Red Hat Linux 不同之处在于 CentOS 并不包含封闭的源代码软件，可以开源免费使用，得到运维人员、企业、程序员的青睐，CentOS 发行版操作系统是目前企业使用最多的系统之一 2014 年 7 月 7 日，正式发布 centos 7 2016 年 12 月 12 日，正式发布了 CentOS7.3。 2019 年 9 月 25 号，正式发布了 Centos8 的新版本。 Ubuntu Ubuntu 是一个以桌面应用为主的 Linux 操作系统，其名称来自非洲南部祖鲁语或豪萨语的“ubuntu”一词（译为吾帮托或乌班图），意思是“人性”、“我的存在是因为大家的存在”，是非洲传统的一种价值观。Ubuntu 基于 Debian 发行版和 GNOME 桌面环境， Ubuntu 发行版操作系统的目标在于为一般用户提供一个最新的、同时稳定的以开放自由软件构建而成的操作系统，目前 Ubuntu 具有庞大的社区力量，用户可以方便地从社区获得帮助。 SUSE Linux SUSE(发音 /ˈsuːsə/)，SUSE Linux 出自德国，SuSE Linux AG 公司发行维护的 Linux 发行版，是属于此公司的注册商标 2003 年 11 月 4 日，Novell 表示将会对 SUSE 提出收购。收购的工作于 2004 年 1 月完成。 Fedora Linux Fedora 是一个知名的 Linux 发行版，是一款由全球社区爱好者构建的面向日常应用的快速、稳定、强大的操作系统。它允许任何人自由地使用、修改和重发布，无论现在还是将来。它由一个强大的社群开发，这个社群的成员以自己的不懈努力，提供并维护自由、开放源码的软件和开放的标准。 Fedora 约每六个月会发布新版本，美国当地时间 2015 年 11 月 3 日，北京时间 2015 年 11 月 4 日，Fedora Project 宣布 Fedora 23 正式对外发布，2017 年 6 月发布 Fedora 26 版本。 Linux 内核命名规则 Linux 内核是 Linux 操作系统的核心，一个完整的 Linux 发行版包括进程管理、内存管理、文件系统、系统管理、网络操作等部分。 Linux 内核版本命名在不同的时期有其不同的命名规范，其中在 2.X 版本中，X 如果为奇数表示开发版、X 如果为偶数表示稳定版，从 2.6.X 以及 3.X，内核版本命名就没有严格的约定规范。 从 Linux 内核 1994 年发布 1.0 发布到目前主流 3.X 版本，5.X 属于开发调试阶段。 查看 Linux 操作系统内核： uname -a Linux 1550684538 3.10.0-693.el7.x86_64 #1 SMP Tue Aug 22 21:09:27 UTC 2017 x86_64 x86_64 x86_64 GNU/Linux 也可以去官网下载内核：www.kernel.org 其中 Mainline 表示主线开发版本，Stable 表示稳定版本，稳定版本主要由 mainline 测试通过而发布。Longterm 表示长期支持版，会持续更新及 Bug 修复，如果长期版本被标记为 EOL（End of Life），则表示不再提供更新。 linux 系统安装 在安装 CentOS 操作系统时，如果没有多余的计算机裸机设备，可以基于 Windows 主机上安装 Vmware workstation 工具，该工具的用途可以在真实机上模拟一个新的计算机完整的资源设备，包括：CPU、内存、硬盘、网卡、DVD 光驱、USB 接口、声卡，进而可以安装 CentOS7.4 系统。 如果有多余的计算机裸机设备或者企业服务器，可以将 CentOS 系统直接安装在多余的设备上，安装之前需要下载 CentOS7.2 操作系统镜像文件(International Organization for Standardization,ISO 9660 标准)，通过刻录工具，将 ISO 镜像文件刻录至 DVD 光盘或者 U 盘里，通过 DVD 或者 U 盘启动然后安装系统。 系统安装及环境准备 VMware workstation 14.0 CentOS 7.4 x86_64 CentOS 7.4 镜像下载 在各大镜像站下载： http://mirrors.163.com https://opsx.alibaba.com 直接选择centos/7/isos/x86_64/,会指向最新的版本，如果要想下载以前的版本，可以到其他目录下下载readme，根据其中的地址，进行下载。 其他发行版，可以在这里选择： http://vault.centos.org/ vm 安装 centos 系统 Vmware 安装好后，执行运行，单击“创建新的虚拟机” 新建虚拟机向导，选择自定义（高级）（C）选项 ： 直接下一步 安装客户机操作系统，选择“稍后安装操作系统 选择客户机操作系统(选择 centos7 64 位) 自定义虚拟机名字，以及选择虚拟机存放位置 选择给虚拟机分配几个 cpu，这个要根据物理机的 cpu 设备情况来配，选择默认就可以了 虚拟机内存设置，默认为 1024MB ，如果物理机内存不够，则可以设置为 512M 网络选择桥接模式： 磁盘大小分配 20G，选择将虚拟磁盘划分为多个文件，便于拷贝，迁移 ps:如果硬盘容量小于 2TB，系统默认会使用 MBR 模式来安装，若需强制使用 GPT 分区，可以在安装时，先选择 install centos 7 ，然后按 tab 键，在 quiet 后面空格输入：inst.gpt 点击完成 点击 CD/DVD，选择使用 ISO 镜像文件 点击启动此虚拟机，即可开始安装 用上下键选择第一个，直接回车，开始安装 修改软件包，附加依赖库，如果对 linux 不属性，可以带 GUI 安装 配置分区： 安装完，重启服务器之后，就可以通过远程工具连接 xshell 连接及配置 三种连接 xshell 的方式 第一种：终端直接 ssh 命令连接 Xshell 6 (Build 0197) Copyright (c) 2002 NetSarang Computer, Inc. All rights reserved. Type `help' to learn how to use Xshell prompt. [D:\\~]\\$ ssh 192.168.115.129 Connecting to 192.168.115.129:22... Connection established. To escape to local shell, press 'Ctrl+Alt+]'. WARNING! The remote SSH server rejected X11 forwarding request. Last login: Tue Jun 30 16:05:52 2020 from 192.168.115.1 [root@xiaobei ~]# 第二种：在标签上方直接输入用户名及主机 ip 连接 ssh://root@ip:端口 第三种：写入常用列表（推荐） 关闭 selinux/firewalld # 临时关闭selinux setenforce 0 # 永久关闭selinux vi /etc/selinux/config SELINUX=disabled # 临时关闭防火墙： systemctl stop firewalld # 永久关闭防火墙： systemctl disable firewalld 虚拟机网络连接方式 桥接模式 通过桥接模式网络连接，虚拟机中的虚拟网络适配器可连接到主机系统中的物理网络适配器，在桥接模式下，虚拟机 ip 地址需要与主机在同一个网段，如果需要联网，则网关与 DNS 需要与主机网卡一致。 修改静态 IP 地址： vim /etc/sysconfig/network-scripts/ifcfg-ens32 TYPE=\"Ethernet\" PROXY_METHOD=\"none\" BROWSER_ONLY=\"no\" #把默认得dhcp修改为none或者static,表示设置静态IP地址 BOOTPROTO=\"none\" DEFROUTE=\"yes\" IPV4_FAILURE_FATAL=\"no\" NAME=\"ens32\" UUID=\"eca2f15c-eacc-48cf-9eea-9251567a4b18\" DEVICE=\"ens32\" #设置为yes ONBOOT=\"yes\" # 静态ip地址得配置，参考物理主机得IP配置： IPADDR=192.168.1.33 GATEWAY=192.168.1.254 NETMASK=255.255.255.0 DNS1=8.8.8.8 DNS2=114.114.114.114 nat 模式 使用 NAT 模式网络时，主机系统上会建立单独的专用网络，虚拟机在外部网络中不必具有自己的 IP 地址。在默认配置中，虚拟机会在此专用网络中通过 DHCP 服务器获取地址。虚拟机和主机系统共享一个网络标识，此标识在外部网络中不可见。在 NAT 模式中，主机网卡直接与虚拟 NAT 设备相连，然后虚拟 NAT 设备与虚拟 DHCP 服务器一起连接在虚拟交换机 VMnet8 上。 仅主机模式 Host-Only 模式其实就是 NAT 模式去除了虚拟 NAT 设备，然后使用 VMwareNetwork Adapter VMnet1 虚拟网卡连接 VMnet1 虚拟交换机来与虚拟机通信的，Host-Only 模式将虚拟机与外网隔开，使得虚拟机成为一个独立的系统，只与主机相互通讯。 By xiaobei，使用知识共享 署名-相同方式共享 4.0协议发布            此页面修订于： 2020-08-15 09:39:51 "},"book/technology/linux/Special-lecture/基础命令讲解一.html":{"url":"book/technology/linux/Special-lecture/基础命令讲解一.html","title":"基础命令讲解(一)","keywords":"","body":"基础命令讲解(一) 常用命令 ls 命令 参数 注释 -a, --all 不隐藏任何以. 开始的项目； -A, --almost-all 列出除. 及.. 以外的任何项目； --author 与-l 同时使用时列出每个文件的作者； -b, --escape 以八进制溢出序列表示不可打印的字符； --block-size=大小 块以指定大小的字节为单位； -B, --ignore-backups 不列出任何以\"~\"字符结束的项目； -d, --directory 当遇到目录时列出目录本身而非目录内的文件； -D, --dired 产生适合 Emacs 的 dired 模式使用的结果； -f 不进行排序，-aU 选项生效，-lst 选项失效； -i, --inode 显示每个文件的 inode 号； -I, --ignore=PATTERN 不显示任何符合指定 shell PATTERN 的项目； -k 即--block-size=1K； -l 使用较长格式列出信息； -n, --numeric-uid-gid 类似 -l，但列出 UID 及 GID 号； -N, --literal 输出未经处理的项目名称 (如不特别处理控制字符) ； -r, --reverse 排序时保留顺序； -R, --recursive 递归显示子目录； -s, --size 以块数形式显示每个文件分配的尺寸； -S 根据文件大小排序； -t 根据修改时间排序； -u 同-lt 一起使用：按照访问时间排序并显示； 同-l 一起使用：显示访问时间并按文件名排序； 其他：按照访问时间排序； -U 不进行排序；按照目录顺序列出项目； -v 在文本中进行数字(版本)的自然排序。 -l 长格式显示文件信息 -d 显示目录本身信息 -a 显示全部文件，包括隐藏的文件 -A 显示除了.或者..以外的文件，包括隐藏文件 -i 显示文件的inode号 -t 按修改时间进行排序 长格式显示 -l 参数主要是可以看到文件的更详细的信息 [root@xiaobei ~]# ll total 4 -rw-------. 1 root root 1840 Jun 30 15:18 anaconda-ks.cfg #第一个横行表示文件类型，常见有 #- 普通文件： #d 目录 #l 链接文件 #c 字符设备（即串行端口的接口设备，例如伪终端等） #b 块设备（磁盘） #s 套接字文件（通常用在网络数据连接） #p 管道文件 [root@xiaobei /]# ll total 16 lrwxrwxrwx. 1 root root 7 Jun 30 15:07 bin -> usr/bin dr-xr-xr-x. 5 root root 4096 Jun 30 15:17 boot drwxr-xr-x. 20 root root 3240 Jun 30 15:40 dev drwxr-xr-x. 81 root root 8192 Jun 30 15:40 etc drwxr-xr-x. 3 root root 21 Jun 30 15:16 home lrwxrwxrwx. 1 root root 7 Jun 30 15:07 lib -> usr/lib lrwxrwxrwx. 1 root root 9 Jun 30 15:07 lib64 -> usr/lib64 drwxr-xr-x. 2 root root 6 Apr 11 2018 media drwxr-xr-x. 2 root root 6 Apr 11 2018 mnt drwxr-xr-x. 2 root root 6 Apr 11 2018 opt dr-xr-xr-x. 116 root root 0 Jun 30 15:40 proc dr-xr-x---. 2 root root 114 Jun 30 15:18 root drwxr-xr-x. 25 root root 740 Jun 30 15:40 run lrwxrwxrwx. 1 root root 8 Jun 30 15:07 sbin -> usr/sbin drwxr-xr-x. 2 root root 6 Apr 11 2018 srv dr-xr-xr-x. 13 root root 0 Jun 30 15:40 sys drwxrwxrwt. 8 root root 167 Jun 30 15:40 tmp drwxr-xr-x. 13 root root 155 Jun 30 15:07 usr drwxr-xr-x. 19 root root 267 Jun 30 15:40 var ### Linux目录结构： / 根目录 /boot: 放置linux系统启动时的内核文件以及引导文件。 /dev： 存放linux系统下的设备文件 /etc: 系统配置文件存放的目录 /home: 系统默认的用户家目录 /lib,lib64: 动态连接共享库 /media: 挂载可移动的设备 /opt: 存放第三方软件 /root: 管理员家目录 /bin,/sbin: 可执行二进制命令 /run: 临时文件系统目录 /srv: 早期存放数据目录 /tmp: 存放临时文件 /usr: 应用程序目录 /var: 存放动态文件，比如日志 /mnt: 临时挂载目录 管道文件又分为有名管道和无名管道： 有名管道： 在磁盘上会存储一个管道文件表示（inode 存于内存上），但它并不会占据磁盘空间（block），数据并不会存储到磁盘上。 创建有名管道： mkfifo xiaobei.pipe [root@xiaobei home]# mkfifo xiaobei.pipe [root@xiaobei home]# ls xiaobei xiaobei.pipe [root@xiaobei home]# ll total 0 drwx------. 2 xiaobei xiaobei 62 Apr 11 2018 xiaobei prw-r--r--. 1 root root 0 Jun 30 16:39 xiaobei.pipe 无名管道： 无名管道不存在管道文件 ip addr | grep \"inet\" [root@xiaobei home]# ip addr | grep \"inet\" inet 127.0.0.1/8 scope host lo inet6 ::1/128 scope host inet 192.168.115.129/24 brd 192.168.115.255 scope global noprefixroute dynamic ens33 inet6 fe80::1036:aab8:fd73:8e4f/64 scope link noprefixroute 显示隐藏文件 -a 参数可以显示隐藏文件 [root@xiaobei ~]# ls -a . .. anaconda-ks.cfg .bash_logout .bash_profile .bashrc .cshrc .tcshrc [root@xiaobei ~]# ls anaconda-ks.cfg pwd 命令 pwd 命令主要用于显示或者查看当前所在的目录路径 [root@xiaobei ~]# pwd /root echo 命令 输出指定得字符或者变量 [root@xiaobei ~]# echo xiaobei xiaobei 参数 注释 \\a 发出警告声 \\b 删除前一个字符 \\c 最后不加上换行符号； \\f 换行但光标仍旧停留在原来的位置； \\n 换行且光标移至行首； \\r 光标移至行首，但不换行； \\t 插入 tab； \\v 与\\f 相同； \\ 插入\\字符； \\033[30m 黑色字 \\033[0m \\033[31m 红色字 \\033[0m \\033[32m 绿色字 \\033[0m \\033[33m 黄色字 \\033[0m \\033[34m 蓝色字 \\033[0m \\033[35m 紫色字 \\033[0m \\033[36m 天蓝字 \\033[0m \\033[37m 白色字 \\033[0m \\033[40;37m 黑底白字 \\033[0m \\033[41;37m 红底白字 \\033[0m \\033[42;37m 绿底白字 \\033[0m \\033[43;37m 黄底白字 \\033[0m \\033[44;37m 蓝底白字 \\033[0m \\033[45;37m 紫底白字 \\033[0m \\033[46;37m 天蓝底白字 \\033[0m \\033[47;30m 白底黑字 \\033[0m cat >/home/echo.sh alias 命令 设置别名，便于执行相关命令 查看当前环境设置的别名： alias 设置临时别名（关闭shell就失效了）： alias v33='vim /etc/sysconfig/network-scripts/ifcfg-ens33' 设置永久别名。 vim ~/.bashrc alias v33='vim /etc/sysconfig/network-scripts/ifcfg-ens33' du 命令 du 命令常用于查看文件在磁盘中的使用量，常用命令 du -sh，查看当前目录所有文件及文件及的大小 文件管理 cat、cp、mv、touch、mkdir、less、more、diff、zip、gzip、bzip2、tar cat 命令 cat 命令可以用于查看文件内容，或者利用重定向创建文件 查看文件内容或追加文件内容 -n 或--number：从 1 开始对所有输出的行数编号； -b 或--number-nonblank：对于空白行不编号； -s 或--squeeze-blank：当遇到有连续两行以上的空白行，就代换为一行的空白行； -A：显示不可打印字符，行尾显示“$”； 实例： [root@xiaobei ~]# cat -n /etc/sysconfig/network-scripts/ifcfg-ens33 1 TYPE=\"Ethernet\" 2 PROXY_METHOD=\"none\" 3 BROWSER_ONLY=\"no\" 4 BOOTPROTO=\"dhcp\" 5 DEFROUTE=\"yes\" 6 IPV4_FAILURE_FATAL=\"no\" 7 IPV6INIT=\"yes\" 8 IPV6_AUTOCONF=\"yes\" 9 IPV6_DEFROUTE=\"yes\" 10 IPV6_FAILURE_FATAL=\"no\" 11 IPV6_ADDR_GEN_MODE=\"stable-privacy\" 12 NAME=\"ens33\" 13 UUID=\"b16d8e90-b790-4873-9747-8a7b50783470\" 14 DEVICE=\"ens33\" 15 ONBOOT=\"yes\" 创建文件 # EOF表示结束符，可以自定义，如下 #以覆盖得方式写文件 [root@xiaobei xiaobei]# cat > xiaobei.txt this > is > xiaobei > test > eof #以追加得方式写文件 [root@xiaobei xiaobei]# cat >> xiaobei.txt new line > f cp 命令 用来将一个或多个源文件或者目录复制到指定的目的文件或目录 语法： cp [OPTION]... SOURCE DEST option: -a：此参数的效果和同时指定\"-dpR\"参数相同； -d：可复制符号连接，不会破坏链接文件与源文件的链接关系。 -f：强行复制文件或目录，不论目标文件或目录是否已存在； -i：覆盖既有文件之前先询问用户； -l：对源文件建立硬连接，而非复制文件； -p：保留源文件或目录的属性； -R/r：递归处理，将指定目录下的所有文件与子目录一并处理； -s：对源文件建立符号连接，而非复制文件（指定绝对路径）； -u：使用这项参数后只会在源文件的更改时间较目标文件要新的时候或是目标文件并不存在时，才复制文件； -S：在备份文件时，用指定的后缀“SUFFIX”代替文件的默认后缀~； -b：覆盖已存在的文件目标前将目标文件备份,后缀默认是~； -v：详细显示命令执行的操作。 复制更新的文件 【-u】只复制源文件有更新的，否则不执行。 #第一次将xiaobei.txt复制到data目录 [root@xiaobei xiaobei]# cp xiaobei.txt /home/data/ #更新文件 [root@xiaobei xiaobei]# echo \"this is update\" > xiaobei.txt #-u参数复制： [root@xiaobei xiaobei]# cp -u xiaobei.txt /home/data/ cp: overwrite ‘/home/data/xiaobei.txt’? y [root@xiaobei xiaobei]# cat /home/data/xiaobei.txt this is update #不更新文件，再次复制，并没有进行替换： [root@xiaobei xiaobei]# cp -u xiaobei.txt /home/data/ 复制软连接 【-d|-a】复制软连接，这里要注意创建软连接时最好为绝对路径，否则可能会出现失效的软连接。 [root@xiaobei xiaobei]# ln -s /home/xiaobei/xiaobei.txt xiaobei2.txt [root@xiaobei xiaobei]# ll total 4 lrwxrwxrwx. 1 root root 25 Jun 30 17:40 xiaobei2.txt -> /home/xiaobei/xiaobei.txt -rw-r--r--. 1 root root 15 Jun 30 17:30 xiaobei.txt #如果直接复制，不带参数，会导致软连接失效，直接创建普通文件 [root@xiaobei xiaobei]# cp xiaobei2.txt /home/data/ [root@xiaobei xiaobei]# ll /home/data/ total 8 -rw-r--r--. 1 root root 15 Jun 30 17:42 xiaobei2.txt -rw-r--r--. 1 root root 15 Jun 30 17:31 xiaobei.txt #加上参数 [root@xiaobei xiaobei]# cp -d xiaobei2.txt /home/data/ cp: overwrite ‘/home/data/xiaobei2.txt’? y [root@xiaobei xiaobei]# ll /home/data/ total 4 lrwxrwxrwx. 1 root root 25 Jun 30 17:43 xiaobei2.txt -> /home/xiaobei/xiaobei.txt -rw-r--r--. 1 root root 15 Jun 30 17:31 xiaobei.txt 备份复制 【-S】复制同名文件到目的目录时，对源文件进行备份，且自定义备份文件后缀名 #第一次复制 [root@xiaobei xiaobei]# echo \"xiaobei3\" > xiaobei3.txt [root@xiaobei xiaobei]# cp xiaobei3.txt /home/data/ #第二次复制，对源文件进行备份 [root@xiaobei xiaobei]# \\cp -S \".`date +%F`\" xiaobei3.txt /home/data/ [root@xiaobei xiaobei]# ls /home/data/ xiaobei2.txt xiaobei3.txt xiaobei3.txt.2020-06-30 xiaobei.txt 通用参数 【-a 】如果参数都记不住，就记住它吧，可以实现递归，复制软连接，保留文件属性 touch 命令 touch 命令有两个功能：一是创建新的空文件，二是改变已有文件的时间戳属性。 touch 命令会根据当前的系统时间更新指定文件的访问时间和修改时间。如果文件不存在，将会创建新的空文件，除非指定了”-c”或”-h”选项。 注意：在修改文件的时间属性的时候，用户必须是文件的属主，或拥有写文件的访问权限 touch file -a 只修改访问时间（属性更改时间也会变） -m 只更改修改时间（属性更改时间也会变） stat file 查看文件的属性 语法格式：touch [参数][文件] | 参数 | 注释 | | :---------: | :----------------------------------------- | | -a | 改变档案的读取时间记录 | | -m | 改变档案的修改时间记录 | | -r | 使用参考档的时间记录，与 --file 的效果一样 | | -c | 不创建新文件 | | -d | 设定时间与日期，可以使用各种不同的格式 | | -t | 设定档案的时间记录，格式与 date 命令相同 | | --no-create | 不创建新文件 | | --help | 显示帮助信息 | | --version | 列出版本讯息 | # 创建空文件 [root@xiaobei xiaobei]# touch file.txt # 批量创建文件 [root@xiaobei xiaobei]# touch file{1..5}.txt [root@xiaobei xiaobei]# ls file1.txt file2.txt file3.txt file4.txt file5.txt file.txt # 修改文件的access(访问)时间 [root@xiaobei xiaobei]# stat file.txt File: ‘file.txt’ Size: 0 Blocks: 0 IO Block: 4096 regular empty file Device: fd00h/64768d Inode: 16847736 Links: 1 Access: (0644/-rw-r--r--) Uid: ( 0/ root) Gid: ( 0/ root) Context: unconfined_u:object_r:home_root_t:s0 Access: 2020-07-02 18:56:34.099010059 +0800 Modify: 2020-07-02 18:56:34.099010059 +0800 Change: 2020-07-02 18:56:34.099010059 +0800 Birth: - [root@xiaobei xiaobei]# touch -a file.txt [root@xiaobei xiaobei]# stat file.txt File: ‘file.txt’ Size: 0 Blocks: 0 IO Block: 4096 regular empty file Device: fd00h/64768d Inode: 16847736 Links: 1 Access: (0644/-rw-r--r--) Uid: ( 0/ root) Gid: ( 0/ root) Context: unconfined_u:object_r:home_root_t:s0 Access: 2020-07-02 18:58:24.913003454 +0800 Modify: 2020-07-02 18:56:34.099010059 +0800 Change: 2020-07-02 18:58:24.913003454 +0800 Birth: - mkdir 命令 创建目录 递归创建目录 -p 如果上级目录不存在,自动创建上级目录，；如果目录已经存在，则不创建，不会提示报错 [root@xiaobei xiaobei]# mkdir -p /home/data/xiaobei/xiaobei 指定目录权限 -m 可以指定创建目录时的权限 [root@xiaobei xiaobei]# mkdir -m 700 /home/xiaobei/xiaobei2 [root@xiaobei xiaobei]# ll /home/xiaobei/xiaobei2 -d drwx------. 2 root root 6 Jun 30 18:03 /home/xiaobei/xiaobei2 rm 命令 rm 命令主要用于删除文件或者目录，用法 rm –rf test.txt (-r 表示递归，-f 表示强制) rm -rf 后面不带路径是最危险的动作，没有之一 mv 命令 mv 命令是“move”单词的缩写，其功能大致和英文含义一样，可以移动文件或对其改名。 这是一个使用频率超高的文件管理命令，我们需要特别留意它与复制的区别：mv 与 cp 的结果不同。mv 命令好像文件“搬家”，文件名称发生改变，但个数并未增加。而 cp 命令是对文件进行复制操作，文件个数是有增加的。 语法格式：mv [参数] 参数 注释 -i 若存在同名文件，则向用户询问是否覆盖 -f 覆盖已有文件时，不进行任何提示 -b 当文件存在时，覆盖前为其创建一个备份 -u 当源文件比目标文件新，或者目标文件不存在时，才执行移动此操作 #将文件file_1重命名为file_2： [root@xiaobei dir]# mv file_1 file_2 # 将文件file移动到目录dir中 ： [root@xiaobei dir]# mv file /dir # 将目录dir1移动目录dir2中（前提是目录dir2已存在，若不存在则改名)： [root@xiaobei dir]# mv /dir1 /dir2 # 将目录dir1下的文件移动到当前目录下： [root@xiaobei dir]# mv /dir1/* . less 命令 查看大文件，分屏显示，可以使用键盘翻屏 空格 显示下一屏内容 b 显示上一屏内容 f 显示下一屏内容 more 命令 也可以实现分屏显示 空格 显示下一屏内容 b 显示上一屏内容 f 显示下两屏内容 gzip 命令 压缩文件，默认压缩完会删除源文件 gzip [option] file -c 将压缩结果通过重定向至其他文件，以此保留源文件。 -d 解压缩 -r 递归压缩目录内文件，只压缩文件，不会压缩目录 -1~9 指定压缩级别，-1 最快压缩，-9 最大压缩，更消耗 cpu，默认级别是 6. 实例 # 压缩一个文件 # gzip file [root@xiaobei xiaobei]# gzip xiaobei.txt # 压缩一个目录下的所有文件,并显示过程 [root@xiaobei xiaobei]# gzip -rv /home/data /home/data/xiaobei.txt: 0.0% -- replaced with /home/data/xiaobei.txt.gz gzip: /home/data/xiaobei2.txt: Too many levels of symbolic links /home/data/xiaobei3.txt.2020-06-30: -22.2% -- replaced with /home/data/xiaobei3.txt.2020-06-30.gz /home/data/xiaobei3.txt: -22.2% -- replaced with /home/data/xiaobei3.txt.gz # 压缩一个文件，并保留源文件 [root@xiaobei xiaobei]# gzip -c /home/xiaobei/xiaobei.txt > xiaobei.gz # 解压一个文件 [root@xiaobei xiaobei]# gunzip xiaobei.gz [root@xiaobei xiaobei]# gzip -d xiaobei.txt.gz # 不解压，直接查看文件内容 [root@xiaobei xiaobei]# zcat xiaobei3.txt.gz xiaobei3 bzip2 命令 压缩文件,默认压缩完会删除源文件,不支持递归压缩目录文件 bzip2 [option] file -k 保留源文件 -d 解压缩 -1~9 定义压缩级别 实例 # 压缩文件，并保留源文件 [root@xiaobei xiaobei]# bzip2 -k xiaobei.txt # 解压缩文件 [root@xiaobei xiaobei]# bzip2 -d xiaobei.txt.bz2 # 不解压，直接查看文件内容 [root@xiaobei xiaobei]# bzcat xiaobei.txt.bz2 this is update tar 命令 归档工具，用来打包和备份 首先要弄清两个概念：打包和压缩 打包是指将一大堆文件或目录变成一个总的文件 压缩则是将一个大的文件通过一些压缩算法变成一个小文件 tar [option] file -c 创建新的 tar 包 -f 指定 tar 包名 -r 添加文件到归档文件，须与 f 结合使用，指定归档文件 -z 指定 gzip 压缩 tar 包，后缀为.tar.gz -j 指定 bzip2 解压缩文件，后缀为.tar.bz2 -p 保留文件的权限和属性 --remove-files 归档后删除源文件 实例 # 创建一个新的归档文件： tar cvf xiaobei.tar file [dirs] # 在一个归档文件中添加新的文件： tar rf xiaobei.tar newfile # 提取归档文件，可以使用-C，提取到指定目录： tar xf xiaobei.tar # 更新归档文件中的newfile个文件 tar uf xiaobei.tar newfile #列出归档文件中的内容，但是如果有更新文件，显示的会有所误差： tar tf xiaobei.tar zip 命令 压缩文件，执行不会删除源文件 # 压缩单个文件： zip fstab.zip fstab # 指定压缩级别： zip -9 fstab2.zip fstab # 压缩目录，并删除源文件： zip -rm xiaobei.zip xiaobei/ 文件传输命令 scp、rsync scp 命令 加密的方式在本地主机和远程主机之间复制文件。 本地目录复制到远程 [root@xiaobei xiaobei]# scp -r /home/xiaobei/ 192.168.115.129:/home/data/ # ps:xiaobei后面不管带不带/，都可以同步xiaobei目录 # 如果只想同步目录下文件 [root@xiaobei xiaobei]# scp -r /home/xiaobei/* 192.168.115.129:/home/data/ 本地文件复制到远程 [root@xiaobei xiaobei]# scp /home/xiaobei/file 192.168.115.129:/home/data/ 启动压缩 [root@xiaobei xiaobei]# scp -rC /home/xiaobei/ 192.168.115.129:/home/data/ rsync 命令 远程数据同步工具，它传送两个文件的不同部分，而不是每次都整份传送，因此速度相当快。 需要注意：本地与远程服务器都需要安装好 rsync 软件包。 | 参数 | 注释 | | :--: | :------------------------------------------------------------------- | -v，–verbose| 详细模式输出，传输时的进度等信息 -z，–compress| 传输时进行压缩以提高传输效率，–compress-level=NUM 可按级别压缩 -a，–archive| 归档模式，表示以递归方式传输文件，并保持所有文件属性，等于-rtopgDl -r，–recursive| 对子目录以递归模式，即目录下的所有目录都同样传输，注意是小写 r -t，–times| 保持文件时间信息 -o，–owner| 保持文件属主信息 -p，-perms |保持文件权限 -g，–group| 保持稳健属组信息 -P，–progress|显示同步的过程及传输时的进度等信息 -D，–devices| 保持设备文件信息 -l，–links| 保留软链接 -e，–rsh=COMMAND| 使用的信道协议，指定替代 rsh 的 shell 程序。 例如：ssh –exclude=PATTERN 指定排除不需要传输的文件模式（和 tar 参数一样） –exclude-from=file（文件名所在目录文件，和 tar 参数一样） –bwlimit=RATE limit socket I/O bandwidth （案例：某 DBA 做数据同步，导致用户无法访问网站） rsync、scp、ftp 都有限速的功能 目录保持绝对一致 # 同步本地目录。 rsync -av --delete A/ /data/B rsync -av --delete A /data/B #ps1: B目录可以不存在，如果不存在则自动创建，但是上级data必须存在。 #ps2: A目录带不带斜杠/，意义是不一样的，带斜杠表示同步A目录下的文件，不带则同步A目录以及其中文件。 #--delete: B与A保持绝对的一致，B中存在，而A中不存在的文件将被删除。 # demo: [root@xiaobei xiaobei]# rsync -av --delete /home/xiaobei /home/data/b sending incremental file list created directory /home/data/b xiaobei/ xiaobei/file xiaobei/file.txt xiaobei/file1.txt xiaobei/file2.txt xiaobei/file3.txt xiaobei/file4.txt xiaobei/file5.txt xiaobei/file_1 xiaobei/file~ sent 2,809 bytes received 226 bytes 6,070.00 bytes/sec total size is 2,224 speedup is 0.73 [root@xiaobei xiaobei]# ls /home/data/b/ xiaobei root@xiaobei xiaobei]# rsync -av --delete /home/xiaobei/ /home/data/a sending incremental file list created directory /home/data/a ./ file file.txt file1.txt file2.txt file3.txt file4.txt file5.txt file_1 file~ sent 2,793 bytes received 225 bytes 6,036.00 bytes/sec total size is 2,224 speedup is 0.74 [root@xiaobei xiaobei]# ls /home/data/a/ file file~ file_1 file1.txt file2.txt file3.txt file4.txt file5.txt file.txt 本地同步到远程 [root@xiaobei xiaobei]# rsync -av /home/xiaobei/a 192.168.115.129:/home/a/ #将本地a目录所有文件，同步至远程服务器上， #同理，要想实现绝对的一致，需要加上--delete参数。 #使用ssh协议连接到远程，所以可以将本机公钥发给远程主机， #否则每次执行都会提示出入密码。 远程同步到本地 [root@xiaobei xiaobei]# rsync -av 192.168.115.129:/home/data/a/ . [root@xiaobei xiaobei]# rsync -av 192.168.115.129:/home/data/a . # . 表示将远程目录a，同步到本地a目录。 #ps：要注意不带斜杠会在本地目录创建一个C目录，如果带上斜杠/,则只会同步C目录下的文件。 开启 shell 扩展 [root@xiaobei xiaobei]# shopt -s extglob [root@xiaobei xiaobei]# rm -rf !(anaconda-ks.cfg) By xiaobei，使用知识共享 署名-相同方式共享 4.0协议发布            此页面修订于： 2020-08-15 09:39:51 "},"book/technology/linux/Special-lecture/基础命令讲解二.html":{"url":"book/technology/linux/Special-lecture/基础命令讲解二.html","title":"基础命令讲解(二)","keywords":"","body":"基础命令讲解(二) 权限管理 Linux 权限是操作系统用来限制对资源访问的机制，权限一般分为读、写、执行。系统中每个文件都拥有特定的权限、所属用户及所属组，通过这样的机制来限制哪些用户或用户组可以对特定文件进行相应的操作。 Linux 每个进程都是以某个用户身份运行，进程的权限与该用户的权限一样，用户的权限越大，则进程拥有的权限就越大。 Linux 权限授权，默认是授权给三种角色，分别是 user、group、other，Linux 权限与用户之间的关联如下： U 代表 User，G 代表 Group，O 代表 Other； 每个文件的权限基于 UGO 进行设置； 权限三位一组（rwx），同时需授权给三种角色，UGO； 每个文件拥有一个所属用户和所属组，对应 UGO，不属于该文件所属用户或所属组使用 O 来表示； 在 Linux 系统中，可以通过 ls –l 查看目录的详细属性 分析图中 xiaobei 的数据 d 表示目录，同一位置如果为-则表示普通文件； rwxr-xr-x 表示三种角色的权限，每三位为一种角色，依次为 u，g，o 权限，如上则表示 user 的权限为 rwx，group 的权限为 r-x，other 的权限为 r-x； 2 表示文件夹的链接数量，可理解为该目录下子目录的数量； 从左到右，第一个 xiaobei 表示该用户名，第二个 xiaobei 则为组名，其他人角色默认不显示； 6 表示该文件夹占据的字节数； Jul 15 16:40 表示文件创建或者修改的时间； xiaobei 为目录的名，或者文件名。 常用命令：chmod、chown、setfacl、chattr、lsattr chmod 二进制权限 Linux 权限默认使用 rwx 来表示，为了更简化在系统中对权限进行配置和修改，Linux 权限引入二进制表示方法 Linux权限可以将rwx用二进制来表示，其中有权限用1表示，没有权限用0表示； Linux权限用二进制显示如下： rwx=111 r-x=101 rw-=110 r--=100 依次类推，转化为十进制，对应十进制结果显示如下： rwx=111=4+2+1=7 r-x=101=4+0+1=5 rw-=110=4+4+0=6 r--=100=4+0+0=4 得出结论，用r=4,w=2,x=1来表示权限 特殊权限及掩码 Linux 权限除了常见的 rwx 权限之外，还有很多特殊的权限，为什么 Linux 目录默认权限 755，而文件默认权限为 644，这是因为 Linux 权限掩码 umask 导致。 每个 Linux 终端都拥有一个 umask 属性，umask 熟悉可以用来确定新建文件、目录的默认权限，默认系统权限掩码为 022。在系统中每创建一个文件或者目录，文件默认权限是 666，而目录权限则为 777，权限对外开放比较大，所以设置了权限掩码之后，默认的文件和目录权限减去 umask 值才是真实的文件和目录的权限。 对应目录权限为：777-022=755； 对应文件权限为：666-022=644； 执行 umask 命令可以查看当前默认的掩码，umask -S 023 可以设置默认的权限掩码 chmod 命令 变更文件或者改变目录权限 | 参数 | 注释 | | :---------: | :----------------------------------------- | |u |用户 user，文件或目录的所有者| |g |用户组 group，文件或目录所属群组| |o |其它用户 others| |a |所有用户 all，系统默认使用此项| |-|添加某些权限| |*|取消某些权限| |= |设置文件的权限为给定的权限| |r |表示可读权限| |w |表示可写权限| |x |表示可执行权限| |s |设置权限 suid 和 sgid，使用权限组合“u+s”设定文件的用户的 ID 位，“g+s”设置组 ID 位| |t |只有目录或文件的所有者才可以删除目录下的文件| |-R |递归处理，将指令目录下的所有文件及子目录一并处理| 设置可读可写 # o+w | o=rw # + 表示直接加上写权限。 # = 表示将其他用户权限设置为可读可写，如果以前还有可执行权限，现在也去掉。 [root@xiaobei home]# mkdir -p /home/file [root@xiaobei home]# ll total 0 drwxr-xr-x. 2 root root 6 Jul 14 19:30 file [root@xiaobei home]# chmod o+w file [root@xiaobei home]# ll total 0 drwxr-xrwx. 2 root root 6 Jul 14 19:30 file # 或者： [root@xiaobei home]# chmod o=rw file [root@xiaobei home]# ll total 0 drwxr-xrw-. 2 root root 6 Jul 14 19:30 file # 对目录进行授权，R表示递归： [root@xiaobei home]# chmod -R o+w /home/file/ 危险操作 将目录权限设置为其他用户可写，这时普通用户是可以进入到目录中任意删除，修改文件名(即使不是自己的文件)，对文件的其他用户权限为不可写的文件也可以强制保存。 # chmod o+w /home/ # xiaobei1用户修改xiaobei2用户的文件： # 提示不能修改 # E45: 'readonly' option is set (add ! to override) # 这时可以强制保存（:wq!） # 【o-w】将目录权限设置为其他用户不可写（目录默认权限755），这时普通用户就无法删除，修改文件名，但是如果文件本身有其他可写权限，还是可以写数据的。 总结一下： 父目录其他用户有可写权限，其下子文件不管有没有可写权限，均可强行写入，修改！ 父目录其他用户没有可写权限，其下子文件只有可写才有写入权限，但不具备删除，修改文件名权限。 设置 t 权限 【-t】 是对目录设置特殊权限，用户只能删除自己的文件 [root@xiaobei home]# chmod o+t /home/file/ [root@xiaobei home]# ll total 0 drwxr-xrwT. 2 root root 6 Jul 14 19:30 file # 小北账户删除file文件 失败 [root@xiaobei ~]# su xiaobei bash-4.2$ cd /home/ bash-4.2$ ls file xiaobei bash-4.2$ rm -rf /home/file/ rm: cannot remove ‘/home/file/’: Permission denied 设置 s 权限 【-s】权限可以设置 suid 和 sgid： “u+s” ： 设置使文件在执行阶段具有文件所有者的权限； “g+s” 任何用户在此目录下创建的文件都具有和该目录所属的组相同的组。 # 【u+s】 # 未设置前，普通用户执行netstat -ntlp，会提示没有root权限，普通用户看不了pid的属主： bash-4.2$ netstat -ntlp (No info could be read for \"-p\": geteuid()=1000 but you should be root.) Active Internet connections (only servers) Proto Recv-Q Send-Q Local Address Foreign Address State PID/Program name tcp 0 0 0.0.0.0:22 0.0.0.0:* LISTEN - tcp 0 0 127.0.0.1:25 0.0.0.0:* LISTEN - # 设置suid后： [root@xiaobei home]# chmod u+s /usr/bin/netstat bash-4.2$ netstat -ntlp Active Internet connections (only servers) Proto Recv-Q Send-Q Local Address Foreign Address State PID/Program name tcp 0 0 0.0.0.0:22 0.0.0.0:* LISTEN 25482/sshd tcp 0 0 127.0.0.1:25 0.0.0.0:* LISTEN 25663/master # 【g+s】 # 任何用户在此目录下创建的文件都具有和该目录所属的组相同的组 [root@xiaobei home]# chmod g+s file/ [root@xiaobei file]# ll total 0 drwxr-srwx. 2 root root 6 Jul 15 10:50 file1 drwxr-srwx. 2 xiaobei root 6 Jul 15 10:52 file2 setfacl 命令 设置文件访问控制列表 修改 acl 规则 通过-m 参数，可以修改文件的 acl 规则。 # 设置用户权限 [root@xiaobei file]# setfacl -m u:xiaobei:rw file1.txt -rw-rw-r--+ 1 root root 0 Jul 15 11:00 file1.txt # getfacl 查看文件acl权限 [root@xiaobei file]# getfacl /home/file/file1.txt # file: home/file/file1.txt # owner: root # group: root user::rw- user:xiaobei:rw- group::r-- mask::rw- other::r-- #第一个user没有写用户名，代表是默认属主root的权限 user::rw- #第二个user代表得是xiaobei用户得权限 user:xiaobei:rw- # 设置组权限 [root@xiaobei file]# setfacl -m g:xiaobei:rw file1.txt # 取消用户所有权限 [root@xiaobei file]# setfacl -m u:xiaobei:- file1.txt # 取消其他用户得所有权限： [root@xiaobei file]# setfacl -m o::- file1.txt # 用户必须存在，否则会报错： [root@xiaobei file]# setfacl -m u:xx:rw file1.txt setfacl: Option -m: Invalid argument near character 3 [root@xiaobei file]# id xx id: xx: no such user [root@xiaobei file]# useradd xx [root@xiaobei file]# setfacl -m u:xx:rw file1.txt #现在xx可以写入数据到file1.txt文件了 [root@xiaobei file]# su xx [xx@xiaobei file]$ echo \"this is xx ! \" > file1.txt [xx@xiaobei file]$ cat file1.txt this is xx ! 批量修改 acl 规则 【-M】从文件中读取相应得权限进行设置，多用于批量管理用户权限 #先创建一个文件： [root@xiaobei home]# touch acl.txt #添加要设置得权限：(创建xx,xx1,xx2,xx3用户) # u:xx:rwx # u:xx1:rw # u:xx2:x # u:xx3:rx [root@xiaobei home]# cat > acl.txt u:xx:rwx > u:xx1:rw > u:xx2:x > u:xx3:rx > EOF #执行,其中file.txt是要进行权限设置得文件： [root@xiaobei home]# setfacl -M acl.txt file.txt [root@xiaobei home]# getfacl file.txt # file: file.txt # owner: root # group: root user::rw- user:xx1:rw- user:xx2:--x user:xx3:r-x group::r-- mask::rwx other::r-- 撤销 acl 权限 【-x】撤销某个用户得 acl 权限，恢复到普通 ugo 权限： #不能单独撤销某一个权限，比如只撤销可写权限 [root@xiaobei home]# setfacl -x u:xx file.txt 【-b】撤销所有用户或者组得 acl 权限： [root@xiaobei home]# setfacl -b file.txt 复制 acl 规则 【--set-file】复制一个文件 acl 权限到另外一个文件。 # [root@xiaobei home]# getfacl file.txt |setfacl --set-file=- file2.txt # -表示输出流 # echo file.txt |cat - 临时降低权限 【mask】会临时降低 acl 用户或者组的权限，只能降低用户权限，不能提升。 # 创建file.txt文件，设置小北 rw权限，此时xiaobei是可写的 [root@xiaobei data]# touch file.txt [root@xiaobei data]# setfacl -m u:xiaobei:rw file.txt [root@xiaobei data]# su xiaobei bash-4.2$ cd /data/ bash-4.2$ echo \"this is xiaobei\" >> file.txt bash-4.2$ exit exit # 设置mask： [root@xiaobei data]# setfacl -m mask::r file.txt # 此时acl用户只有只读权限，不可写 [root@xiaobei data]# su xiaobei bash-4.2$ echo \"this is xiaobei\" >> /data/file.txt bash: /data/file.txt: Permission denied 注意：如果 xiaobei 用户本身 r 权限（只读权限），即使 mask 设置为 rw，也是不能写的。 而且设置了 mask 之后，如果再次使用 setfacl 进行权限的设置，那么 mask 的作用就失效了。 chattr 命令 改变文件属性 只允许追加 【+a】让某个文件只能往里面追加内容，不能删除。 [root@xiaobei data]# chattr +a /data/file.txt #去掉属性就是-a [root@xiaobei data]# chattr -a /data/file.txt 完全限制 【+i】完全限制系统中某个关键文件，不能被修改，删除。 [root@xiaobei data]# chattr +i /data/file.txt 用户管理 Linux 用户在操作系统可以进行日常管理和维护，涉及到的相关配置文件如下： /etc/passwd 保存用户信息 /etc/shdaow 保存用户密码（以加密形式保存） /etc/group 保存组信息 /etc/login.defs 用户属性限制,密码过期时间,密码最大长度等限制 /etc/default/useradd 显示或更改默认的 useradd 配置文件 命令：useradd、passwd、userdel、usermod、groupadd、groupdel useradd 创建的新的系统用户 默认是在/home 下创建家目录： [root@xiaobei data]# su - xiaobei Last login: Wed Jul 15 11:51:40 CST 2020 on pts/1 -bash-4.2$ pwd /home/xiaobei 指定家目录的根 【-b】指定用户家目录的根目录，会自动创建用户家目录。 [root@xiaobei data]# useradd -b /data/ xiaobei2 [root@xiaobei data]# su - xiaobei2 [xiaobei2@xiaobei ~]$ pwd /data//xiaobei2 [xiaobei2@xiaobei ~]$ 指定家目录 【-d】指定用户的家目录，即指定的目录即为家目录，也会自动创建。 [root@xiaobei data]# useradd -d /data/xiaobei3/ xiaobei3 [root@xiaobei data]# su - xiaobei3 [xiaobei3@xiaobei ~]$ pwd /data/xiaobei3/ 指定系统用户 【-r】指定创建系统用户 [root@xiaobei data]# useradd -r xiaobei4 [root@xiaobei data]# id xiaobei4 uid=998(xiaobei4) gid=996(xiaobei4) groups=996(xiaobei4) 指定 shell 【-s】指定用户登入后所使用的 shell [root@xiaobei data]# useradd -s /sbin/nologin xiaobei5 [root@xiaobei data]# grep \"xiaobei5\" /etc/passwd xiaobei5:x:1008:1008::/home/xiaobei5:/sbin/nologin # 用户不能登录系统，多用于创建系统服务用户 passwd 锁定密码 【-l】锁定用户密码，用户登录不了 [root@xiaobei data]# passwd -l xiaobei1 Locking password for user xiaobei1. passwd: Success # 用普通用户身份进行切换，因为root切换普通用户，不需要输入密码，所以会感觉没生效 [root@xiaobei data]# su xiaobei1 # 先切换其他账号，再切换回xiaobei1 [root@xiaobei data]# su xiaobei bash-4.2$ su xiaobei1 Password: su: Authentication failure # 或者用ssh登录普通用户，也可以验证 ssh xiaobei1@192.168.115.129 解锁密码 【-u】解锁用户密码 [root@xiaobei data]# passwd -u xiaobei1 Unlocking password for user xiaobei1. passwd: Success [root@xiaobei ~]# su xiaobei bash-4.2$ su - xiaobei1 Password: Last login: Wed Jul 15 14:32:51 CST 2020 on pts/0 注销密码 【-e】使用户密码立即失效 [root@xiaobei ~]# passwd -e xiaobei1 Expiring password for user xiaobei1. passwd: Success # 已经登录不上了 [root@xiaobei ~]# su xiaobei bash-4.2$ su xiaobei1 Password: You are required to change your password immediately (root enforced) 非交互方式修改密码 【--stdin】通过标准输入设置用户密码 [root@xiaobei ~]# echo \"123456\" | passwd --stdin xiaobei1 Changing password for user xiaobei1. passwd: all authentication tokens updated successfully. userdel 删除用户以及相关数据，但是如果不加参数，则只删除用户，不删除其家目录 [root@xiaobei ~]# useradd xiaobei6 [root@xiaobei ~]# ls /home/ xiaobei xiaobei1 xiaobei5 xiaobei6 [root@xiaobei ~]# userdel xiaobei5 [root@xiaobei ~]# ls /home/ xiaobei xiaobei1 xiaobei5 xiaobei6 删除用户家目录 【-r】删除用户的同时，删除与用户相关的所有文件 [root@xiaobei ~]# useradd xiaobei7 [root@xiaobei ~]# ls /home/ xiaobei xiaobei1 xiaobei5 xiaobei6 xiaobei7 [root@xiaobei ~]# userdel -r xiaobei7 [root@xiaobei ~]# ls /home/ xiaobei xiaobei1 xiaobei5 xiaobei6 强制删除在线用户 【-f】强制删除用户，即使用户已经登录，默认情况下，用户在线，是不能删除的，因为用户可能正在执行相关操作 [root@xiaobei ~]# userdel xiaobei1 userdel: user xiaobei1 is currently used by process 78724 [root@xiaobei ~]# userdel -rf xiaobei1 userdel: user xiaobei1 is currently used by process 78724 [root@xiaobei ~]# id xiaobei1 id: xiaobei1: no such user usermod 修改用户的基本信息，不允许改变正在线上的使用者帐号名称 修改用户名 【-l】修改用户名 [root@xiaobei ~]# useradd xiaobei2 [root@xiaobei ~]# usermod -l xiaobei3 xiaobei2 [root@xiaobei ~]# id xiaobei2 id: xiaobei2: no such user [root@xiaobei ~]# id xiaobei3 uid=1006(xiaobei3) gid=1006(xiaobei2) groups=1006(xiaobei2) 添加附加组 【-a】用户添加附加组 [root@xiaobei ~]# usermod -a -G wheel xiaobei bash-4.2$ ps -ef |grep nginx xiaobei 79109 79100 0 16:00 pts/3 00:00:00 grep nginx 修改用户家目录 【-d】修改用户登入时的目录，只是修改/etc/passwd 中用户的家目录配置信息，不会自动创建新的家目录，通常和-m 一起使用。 如果已经使用-d 执行了，可以立马去创建其家目录，并将/etc/skel/.bash* 文件拷贝进去 移动用户家目录 【-m】移动用户家目录到新的位置，不能单独使用，一般与-d 一起使用 [root@xiaobei ~]# useradd xiaobei3 [root@xiaobei ~]# usermod -md /data/new xiaobei3 [root@xiaobei ~]# su - xiaobei3 [xiaobei3@xiaobei ~]$ pwd /data/new [xiaobei3@xiaobei ~]$ groupadd 创建一个新的工作组 # 创建普通组 [root@xiaobei ~]# groupadd web # 创建系统组 [root@xiaobei ~]# groupadd -r web2 # 创建指定id的组 [root@xiaobei ~]# groupadd -g 500 web3 [root@xiaobei ~]# grep \"web3\" /etc/group web3:x:500: # 查看组信息 [root@xiaobei ~]# tail /etc/group sshd:x:74: postdrop:x:90: postfix:x:89: stapusr:x:156: stapsys:x:157: stapdev:x:158: xiaobei:x:1000:xiaobei web:x:1001: web2:x:996: web3:x:500: groupdel 删除指定的工作组 [root@xiaobei ~]# groupdel web [root@xiaobei ~]# groupdel web2 [root@xiaobei ~]# groupdel web3 [root@xiaobei ~]# grep \"web\" /etc/group By xiaobei，使用知识共享 署名-相同方式共享 4.0协议发布            此页面修订于： 2020-08-15 09:39:51 "},"book/technology/linux/Special-lecture/vim编辑器.html":{"url":"book/technology/linux/Special-lecture/vim编辑器.html","title":"vim 编辑器","keywords":"","body":"vim 编辑器 vim 的几种模式 命令模式 一般命令模式、底部命令模式 可以使用快捷键命令，或者:输入命令 插入模式 可以输入文本，在正常模式下，按 i、a、o 等都可以进入插入模式 可视模式（visual model） 正常模式下按 v 可以进入可视模式，在可视模式下，移动光标可以选择文本 按 v 进入可视模式，总是整行选中 ctrl+v 进入视块模式 viw 选中单词 vis 选中整段 vi( 选中括号内的所有字符 最常用命令 进入编辑模式 a 在当前光标后面插入 A 在行尾插入 i 在当前光标插入 I 在行首插入 o 在下一行插入 O 在上一行插入 ciw 删除当前一个单词，并进入插入模式 ct\" 删除双引号中间的内容，并进入插入模式 ctf 删除从当前位置到下一个f字符之间的字符 自动填充 在输入模式下输入部分字符然后输入 ctrl +x 和 ctrl + n 用正在编辑的文件的内容作为关键字补齐。 ctrl +x 和 ctrl + f 以当前目录内的文件名作为关键字补齐。 ctrl +x 和 ctrl + o 以拓展名作为语法填充，以vim内建的关键词补齐。（必须要写对文件拓展名，比如.html,.php等等） 光标定位 A|end|$ 将光标定位到行尾 0|home|^ 将光标定位到行首 gg 将光标定位到文件第一行 G 将光标定位到最后一行 w 前移一个单词，光标停在下一个单词开头； e 前移一个单词，光标停在下一个单词末尾； b 后移一个单词，光标停在上一个单词开头； nG 到文件第n行。 :n 移动到第n行。 fm 快速定位到当前行，光标之后的第一个m字符处（通常在行首使用），如果有多个相同字符，可以使用分号；进行下一个选择。 Fm 同上，只是反向查找。 复制/剪切/粘贴 yy 复制整行 p(小写) 粘贴（在下一行粘贴） P（大写) 粘贴（在上一行粘贴） y$|y+end 从光标当前位置复制到行尾。 y0 从光标当前位置复制到行首。 d$|D|d+end 删除（剪切）当前位置到行尾的内容。 d0|d+home 删除（剪切）当前位置到行首的内容。 [n] dd 删除（剪切）1(n)行。 :m,nd 剪切m行到n行的内容。 dgg 剪切光标以上的所有行。 dG 剪切光标以下的所有行。 daw和das 剪切一个词和剪切一个句子，即使光标不在词首和句首也没关系 替换（一般命令模式） r 替换光标处的字符，同样支持汉字。 R 进入替换模式，按esc回到正常模式。 替换（底部命令模式） :s/old/new 用new替换当前行第一个old。 :s/old/new/g 用new替换当前行所有的old。 :n1,n2s/old/new/g 用new替换文件n1行到n2行所有的old。 :%s/old/new/g 用new替换文件中所有的old。 :%s/^/xxx/g 在每一行的行首插入xxx，^表示行首。 :%s/$/xxx/g 在每一行的行尾插入xxx，$表示行尾。 所有替换命令末尾加上c，每个替换都将需要用户确认。 如：%s/old/new/gc 文档保存/退出 :wq 保存并退出。 ZZ 保存并退出。 :x 保存并退出 :q 文档未编辑时，可以直接退出。 :q! 文档编辑过了，强行退出，不保存。 :w 保存修改。 :w file2 将修改的文件保存到另外一个文件。 :r file3 读取当前目录下的file3内容到当前文档。 :e! 一个文档修的地方太多了，最后自己都不知道哪里改对了，哪里改错了，可以使用重新加载文档，丢弃已做的改动。 :Sex 水平分割一个窗口，浏览文件系统，等同 vim -o file1 file2； :Vex 垂直分割一个窗口，浏览文件系统,等同于vim -O file1 file2； ctrl +w 连按两次w,可实现两个窗口的切换 % 快速匹配括号 gf 打开以光标所在字符串为文件名的文件。然后使用ctrl + ^ 可以再次回到源文件。 基本排版 先输入v进入可视化模式，向右缩进一个shiftwidth :ce(nter) 本行文字居中 :le(ft) 本行文字靠左 :ri(ght) 本行文字靠右 编辑多个文件 vim a.txt b.txt c.txt -p * 使用:next(:n)编辑下一个文件。 * :2n 编辑下2个文件。 * 使用:previous或:N编辑上一个文件。 * 使用:wnext，保存当前文件，并编辑下一个文件。 * 使用:wprevious，保存当前文件，并编辑上一个文件。 改变大小写 shift ~: 反转光标所在字符的大小写。 可视模式下的U：把选中的文本变为大写或小写。 v 可视字符 ，可以选择多个字符 ，再按U ，可以将小写切换为大写 V 可视行，可以选择多行，再按u，可以将大写切换为小写 文件加密解密 vim -x file 开始编辑一个加密的文件。 :X 为当前文件设置密码。 :set key= 去除文件的密码。 折叠 zf 创建折叠的命令，可以在一个可视区域上使用该命令，可缩减空间方便阅读； zo 打开折叠的文本 zc 收起折叠； zd 删除当前行的折叠，删除之后就不能再次折叠了； za 打开/关闭当前折叠； zfap 折叠光标所在的段； 常见的设置 智能缩进 :set si 设置 :set nosi 取消 自动对齐 :set ai 设置 :set noai 取消 显示行号 :set nu 显示 :set nonu 取消 语法高亮 :syntax on 开启 :syntax off 取消 显示换行符 :set list 显示 :set nolist 取消 设置文件格式 :set fileformat=dos 设置windows格式 :set fileformat=unix 设置unix格式 :set ff=unix|dos 简写 增量搜索 :set incsearch 显示命令 :set showcmd 更换主题 :colorscheme 显示当前主题 :colorscheme 空格 + ctrl +d 显示所有可用主题 :colorscheme morning 更换主题 By xiaobei，使用知识共享 署名-相同方式共享 4.0协议发布            此页面修订于： 2020-08-15 09:39:51 "},"book/technology/linux/Special-lecture/yum管理.html":{"url":"book/technology/linux/Special-lecture/yum管理.html","title":"yum 管理","keywords":"","body":"yum 管理 yum 命令是在 Fedora 和 RedHat 以及 SUSE 中基于 rpm 的软件包管理器，它可以使系统管理人员交互和自动化地更细与管理 RPM 软件包，能够从指定的服务器自动下载 RPM 包并且安装，可以自动处理依赖性关系，并且一次安装所有依赖的软体包，无须繁琐地一次次下载、安装。 yum 的工作原理 当我们执行 yum install nginx -y，yum 会先访问本地缓存，如果有直接安装，如果没有，则通过元数据找到该软件包，通过该软件内部数据库的提示，找到相应的依赖包，然后继续查找元数据中是否有这些依赖包，如果没有会提示依赖包没有镜像提供。如果 nginx 软件包和依赖包都找到了，就根据配置文件中的 url 去下载。 配置网络源 # 安装163的yum源： wget -O /etc/yum.repos.d/CentOS7-Base-163.repo http://mirrors.163.com/.help/CentOS7-Base-163.repo # 安装阿里云的yum源： wget -O /etc/yum.repos.d/CentOS-Base.repo http://mirrors.aliyun.com/repo/Centos-7.repo 重新执行: yum makecache 搜狐没有现成的 yum 源文件下载，需要自己配置： [sohu] name=Centos-$releasever-sohu baseurl=http://mirrors.sohu.com/centos/$releasever/os/$basearch gpgcheck=1 gpgkey=http://mirrors.sohu.com/centos/$releasever/os/$basearch/RPM-GPG-KEY-CentOS-$releasever 配置本地源 mkdir /mnt/cdrom mount /dev/cdrom /mnt/cdrom vim /etc/yum.repos.d/centos-7-local.repo [local] name=centos-$releasever-local baseurl=file:///mnt/cdrom gpgcheck=1 gpgkey=file:///mnt/cdrom/RPM-GPG-KEY-CentOS-$releasever 自动配置仓库 # 安装yum的扩展包： yum install yum-utils -y # 自动配置国内epel仓库： yum-config-manager --addrepo=https://mirrors.tuna.tsinghua.edu.cn/epel/7/x86_64/ 禁用/启用仓库 # epel 是仓库的id [epel] yum-config-manager --disable epel yum-config-manager --enable epel # 查看仓库状态： yum repolist all yum 常用命令 yum repolist {all|enabled|disabled} 列出所有/已启用/已禁用的yum源 yum list {all|installed|avaliable} 列出所有/已安装/可安装的软件包 yum info package 显示某一个软件包的信息 yum install package 安装软件包 yum reinstall package 重新安装软件包 yum remove|erase package 卸载软件包 yum provides files 查询某个文件是哪个软件包生成的 yum search file 查询某个文件是哪个软件包生成的 同步外网源 在企业实际应用场景中，仅仅靠光盘里面的 RPM 软件包是不能满足需要，我们可以把外网的 YUM 源中的所有软件包同步至本地，可以完善本地 YUM 源的软件包数量及完整性 安装 reposync 工具 yum install yum-utils createrepo -y 同步源 # 创建本地目录: mkdir /data/{centos,epel} # 同步yum源： reposync -r base -r updates -p /data/centos/ # 生成元数据： createrepo /data/centos # 结合前面所学制作本地源，如果想让其他服务器使用该源，后面可以结合nginx发布。 By xiaobei，使用知识共享 署名-相同方式共享 4.0协议发布            此页面修订于： 2020-08-15 09:39:51 "},"book/technology/linux/Special-lecture/nfs文件共享服务器.html":{"url":"book/technology/linux/Special-lecture/nfs文件共享服务器.html","title":"nfs 文件共享服务器","keywords":"","body":"nfs 文件共享服务器 NFS 是 network file sytem 的缩写，他最大的特点就是可以通过网络，让不同的机器，不同的系统实现文件共享。NFS 客户端可以将 NFS 服务器共享的目录挂载在本地的文件系统中，访问目录就如同访问自己本地目录一样。 NFS 工作原理 首先 NFS 服务器端开启 rpcbind； 然后服务端开启 NFS 服务，这时 NFS 的各项功能都需要向 RPC 服务注册，这时 rpc 会通知 portmap 模块将可用的端口分配给 statd，rquotad 等; 然后 NFS 客户端 RPC 服务就会通过网络向 NFS 服务端的 RPC 服务的 111 端口发出 NFS 文件存取功能的询问请求。 NFS 服务端的 RPC 服务找到对应的已注册的 NFSdaemon 端口后，通知 NFS 客户端的 RPC 服务。 此时 NFS 客户端就可获取到 nfs 服务端各个进程的正确端口，然后通过 客户端 rpc 就直接与 NFS 服务器的 rpc 进行存取数据了（rpc 知道了 nfs 的 具体端口，就可以实现远程调用，即传输）。 NFS 安装和部署 服务器和客户端都关闭防火墙，装好 nfs 服务组件 nfs 服务端：192.168.115.130 nfs 客户端：192.168.115.131 # 关闭防火墙： systemctl stop firewalld && systemctl disable firewalld # 临时关闭selinux: setenforce 0 # 永久关闭selinux: sed -i 's/=enforcring/=disabled/' /etc/selinux/config # 安装nfs服务组件： yum -y install nfs-utils 配置服务端 编辑/etc/exports 文件 /data/nfs 192.168.115.0/24(rw,sync) # 格式： # /data/nfs 要共享的目录，需要存在 # 192.168.115.0/24 谁能挂载使用，可以是网段，也可以指定具体ip # (rw,sync) 挂载的一些参数，rw表示挂载为可读可写，sync表示同步 导出（广播）编辑的文件，并重启 rpc 和 nfs 服务 systemctl restart rpcbind systemctl restart nfs exportfs -r 配置客户端 可用 showmount 搜索网络中可用的共享文件 showmount -e 192.168.115.130 创建目录，用于挂载 mkdir /mnt/nfs 挂载 mount -t nfs 192.168.115.131:/data/nfs /mnt/nfs #推荐使用： mount -t nfs -o soft,timeo=1 192.168.115.131:/data/xiaobei/mnt/nfs # soft： 软挂载，遇到报错会终止挂载，并返回信息，默认是硬挂载，一直尝试挂载。 # timeo: 超时时间，如果不设置，一直链接，可以设置小点 挂载完成之后，进入目录，可能会发现无法对目录中的文件进行修改。这主要是因为客户端访问服务器时，身份被压缩成 nobody，相对服务器文件系统来说，就是其他用户。所以要想编辑，需要在服务端对文件授权或者更改 exports 文件，设置 no_root_squash（不压缩客户端 root 身份）。 解读 exports 文件 [root@localhost ~]# exportfs -v /data/nfs 192.168.115.0/24(sync,wdelay,hide,no_subtree_check,sec=sys,rw,secure,no_root_squash,no_all_squash) 其中： rw:可读可写 ro:仅可读 sync:是指数据同步写入内存和磁盘 root_squash:如果客户端用 root 身份访问，则被压缩成 nobody,权限也将受到限制。 no_root_squash:也就是不压缩，客户端使用 root 身份登录，全有所有权限，很危险。 all_squash:不管访问者是什么身份，包括 root，全部压缩至匿名用户。 no_all_squash:保留访问用户的身份 uid 以及 gid,一般只能查看，不能修改，权限问题，但是可以强制保存。 报错处理 卸载时报错 umount.nfs4: /mnt/nfs: device is busy umount -l /mnt/nfs 强行解除挂载 或者使用 fuser -m /mnt/nfs 将会显示使用这个模块的pid fuser -mk /mnt/nfs 将会直接kill那个pid nfs 自动挂载技术 autofs 服务程序与 mount 命令不同之处在于它是一种守护进程，只有检测到用户试图访问一个尚未挂载的文件系统时才自动的检测并挂载该文件系统。 autofs 非常方便，主要有两点： 1、设置开机不一定要挂载的目录，当用的时候才实现自动挂载。 2、用户不使用自动挂载的目录一段的时间，会自动卸载。（默认时间为 5 分钟）,可以在 autofs.conf 安装 autofs 服务 # 在客户端执行以下命令： yum install autofs -y # 配置autofs rpm -qc autofs 编辑/etc/auto.master # 添加以下行： /media /etc/nfs.misc #/media 挂载点 #/etc/nfs.misc是对总访问目录的描述，用于子目录的编辑，用户权限分离 编辑 nfs.misc /data/nfs -fstype=nfs,rw,sync 192.168.115.129:/data/nfs /data/nfs -fstype=nfs,ro,sync 192.168.115.129:/data/nfs 启动 nfs systemctl start autofs 权限验证 ## 登录不同目录验证权限： [root@node nfs]# ls [root@node nfs]# [root@node nfs]# [root@node nfs]# cd xiaobei [root@node xiaobei]# df By xiaobei，使用知识共享 署名-相同方式共享 4.0协议发布            此页面修订于： 2020-08-15 09:39:51 "},"book/technology/linux/Special-lecture/ftp文件服务器.html":{"url":"book/technology/linux/Special-lecture/ftp文件服务器.html","title":"ftp 文件服务器","keywords":"","body":"ftp 文件服务器 vsftpd 是“very secure FTP daemon”的缩写，是一个完全免费的、开放源代码的 ftp 服务器软件。特点是：非常高的安全性需求、带宽限制、良好的可伸缩性等。 工作原理 vsftpd 使用 ftp 协议，该协议属于应用层协议。它是典型的 c/s 架构，ftp 服务端用来存储文件，ftp 客户端可以通过 ftp 协议连接服务端实现上传和下载资源。 ftp 使用 tcp 的 21 端口进行命令传输，然后用 tcp 的 20 端口进行数据传输（主动模式）。默认是被动模式。 安装部署 [root@localhost ~]# yum install vsftpd ftp lftp -y #vsftpd: 为服务端软件 #ftp、lftp： 为客户端工具，推荐使用lftp 启动服务 systemctl start vsftpd 匿名用户访问 用 ftp 客户端匿名登录需要输入用户名及密码验证，匿名用户名为：ftp 或者 anonymous，密码为空。 用 lftp 客户端匿名登录则不需要输入以上信息。 # ftp客户端连接： [root@localhost ~]# ftp 192.168.115.129 ftp: connect: Connection refused ftp> # lftp客户端连接: [root@localhost ~]# lftp 192.168.115.129 lftp 192.168.115.129:~> 这里我们重点讲 lftp 使用方法，ftp 客户端工具使用方法大致相同。 下载命令 get 下载单个文件 可以先切换到本地指定目录（data）进行文件的下载，保存 lftp 192.168.115.132:~> lcd /data/ lcd ok, local cwd=/data lftp 192.168.115.132:~> get xiaobei # 下载到指定目录(默认使用源文件名，可以自定义名)： lftp 192.168.115.132:/> get xiaobei -o /tmp ps:当客户端已经连接上服务端，cd 是用于切换服务器中的目录命令，如果想切换客户端本地的目录则使用 lcd 命令 mget 批量下载 lftp 192.168.115.132:/> mget * 默认配置只能进行文件的读取和下载，不能进行写入和上传文件： lftp 192.168.115.132:/> put /etc/fstab put: Access failed: 550 Permission denied. (fstab) lftp 192.168.115.132:/> mkdir abc mkdir: Access failed: 550 Permission denied. (abc) 可以看到上传命令和创建命令都失败了，没有相应的权限！ 开启匿名用户创建文件，重命名，删除，上传权限 # 地址 /etc/vsftpd/vsftpd.conf #开启上传权限 anon_upload_enable=YES #开启创建文件权限 anon_mkdir_write_enable=YES #开启重命名，删除权限 anon_other_write_enable=YES anon_umask=022 重启服务，再次进入，发现还是没法创建目录，但是报错信息不一样:mkdir: Access failed: 550 Create directory operation failed. 这是因为目录没有写权限，给 pub 目录授权，小总结：要想匿名用户有写的权限，一是需要服务端配置文件开启写的权限，二是所在的目录本身有其他用户写的权限！ 上传命令 put 上传单个文件 要想使用上传命令，需要开启上传权限和可写权限 语法：put [OPTS] [-o ] 直接上传不改名，可以省去-o refile,如果不知道本地目录有哪些文件，可以使用!dir 查看，如下： lftp 192.168.115.132:/pub> !dir anaconda-ks.cfg favicon.png lftp 192.168.115.132:/pub> put /etc/fstab 501 bytes transferred mput 批量上传 上传多个文件，可以使用 put 和 mput 命令上传，多个文件之间用空格分隔，如果想使用通配符，只有 mput 命令支持 lftp 192.168.115.132:/pub> put /etc/fstab /etc/favicon.png lftp 192.168.115.132:/pub> mput /etc/f* 下载目录 # 下载远程服务器pub目录下的xiaobei 到本地的/root下 lftp 192.168.115.132:/> lcd lcd ok, local cwd=/root lftp 192.168.115.132:/> mirror -c xiaobei # -c 支持断点续传 上传目录 lftp 192.168.115.132:/> mirror -cR /tmp # 默认上传目录后，是不能查看目录内容的，需要添加mask权限 vim /etc/vsftpd/vsftpd.conf anon_umask=022 同步远程目录 # 同步当前目录文件： lftp 192.168.0.130:/pub> lcd lcd 成功, 本地目录=/root lftp 192.168.0.130:/pub> mirror -ce -e 该参数会将远程目录pub下的文件同步到本地的root目录下，并且删除本 地多余的文件（远程目录没有的文件） # 同步指定目录，如果是想同步整个目录，需要在本地端路径加上目录名： lftp 192.168.0.130:/pub> mirror -ce xiaobei /root/xiaobei #同步指定目录文件，如果是同步指定目录下的文件，不同步目录本身，就不需 要指目录了： lftp 192.168.0.130:/pub> mirror -ce xiaobei /root # xiaobei为远程服务器pub目录下的一个目录 # root为本地的目录 删除目录 # 删除目录： lftp 192.168.0.103:/pub> rm -rf abc # 删除空目录： lftp 192.168.0.103:/pub> rmdir abc rmdir ok, `abc' removed 删除文件 lftp 192.168.115.132:/pub> rm -rf xiao 本地用户访问 如果使用本地用户访问，需要服务端有对应的用户存在才行 # 服务端设置用户名及密码： [root@localhost ~]# id xiaobei uid=1000(xiaobei) gid=1000(xiaobei) 组=1000(xiaobei) [root@localhost ~]# echo \"xiaobei\" |passwd --stdin xiaobei #更改用户 xiaobei 的密码 。 #passwd：所有的身份验证令牌已经成功更新 修改配置文件，可以设置不让匿名用户登录 ，只能本地用户登录 vim /etc/vsftpd/vsftpd.conf anonymous_enable=NO local_enable=YES 重启服务。然后再次访问 systemctl restart vsftpd [root@www ~]# lftp 192.168.115.132 192.168.115.132:~> ls #上面这个登录，表示匿名用户已经无法登录了。 [root@www ~]# lftp xiaobei:xiaobei@192.168.115.132 lftp xiaobei@192.168.115.132:~> ls lftp xiaobei@192.168.115.132:~> 限制系统用户越狱 在安装 vsftpd 后不做配置的话，系统用户是可以向上切换到其他目录的。在配置文件中，添加如下选项 vim /etc/vsftpd/vsftpd.conf chroot_local_user=YES chroot_list_enable=NO allow_writeable_chroot=YES # chroot_local_user： 是否将所有用户限制在主目录,YES为启用，NO禁 用.(该项默认值是NO) # chroot_list_enable： 是否启动限制用户（特例）的名单 YES为启用， NO禁用(包括注释掉也为禁用) 如果想全部限制，所有用户都不能切换家目录，就可以像上面的配置 chroot_local_user=YES chroot_list_enable=NO allow_writeable_chroot=YES 如果想让部分用户有切换的家目录的权限，则需要开启限制 chroot_local_user=YES chroot_list_enable=YES chroot_list_file=/etc/vsftpd/chroot_list chroot_list中写上要放行用户 By xiaobei，使用知识共享 署名-相同方式共享 4.0协议发布            此页面修订于： 2020-08-15 09:39:51 "},"book/technology/linux/Special-lecture/nginx服务安装及配置文件.html":{"url":"book/technology/linux/Special-lecture/nginx服务安装及配置文件.html","title":"nginx 服务安装及配置文件","keywords":"","body":"常见服务器 nginx、tengine、httpd、tomcat、IIS、lighttpd httpd|IIS 政府类，银行用的居多 nginx|tomcat|tengine 社区，电商用的多 nginx 新浪、 httpd 中国人民政府网站、兴业银行... IIS 招商银行、工商银行、农业银行... tengine(2012) 简书、csdn、淘宝... nginx 发展 第一个公开版本 0.1.0 发布于 2004 年 10 月 4 日。 Nginx 的 1.4.0 稳定版已经于 2013 年 4 月 24 日。 Nginx 目前最新的版本是 1.18.0，于 2020 年 4 月 21 号发布。 nginx 的安装方式 YUM 安装部署 源码安装部署 yum 安装 配置 yum 仓库 登录http://nginx.org官网，点击右侧的download： 点击 当前页最下方的 stable and mainline： 然后选择 RHEL/CentOS 复制配置文件，创建 nginx.repo 文件 vim /etc/yum.repos.d/nginx.repo [nginx-stable] name=nginx stable repo baseurl=http://nginx.org/packages/centos/$releasever/$base arch/ gpgcheck=1 enabled=1 gpgkey=https://nginx.org/keys/nginx_signing.key [nginx-mainline] name=nginx mainline repo baseurl=http://nginx.org/packages/mainline/centos/$release ver/$basearch/ gpgcheck=1 enabled=0 gpgkey=https://nginx.org/keys/nginx_signing.key 现在就可以直接安装了，默认情况是安装稳定版的 安装稳定版本 [root@localhost ~]# yum install nginx -y [root@localhost ~]# nginx -v nginx version: nginx/1.16.0 安装主线版本 # 先安装yum的扩展包，开启nginx的主线版本仓库： yum install yum-utils -y yum-config-manager --enable nginx-mainline yum install nginx -y 这个时候 nginx 1.16 的版本会直接被升级。 [root@localhost ~]# nginx -v nginx version: nginx/1.17.1 源码安装 登录http://nginx.org官网，点击右侧的download： 主线版本：也叫开发版本，目前最新但是还没有经过大量测试的版本。 稳定版本：稳定版通常是经过大量测试的，相对比较稳定的版本，企业中我们也会使用稳定版。 历史版本：通常是往期的稳定版本 下载包 # 选择想要下载的版本，直接单击右键复制地址下载： wget http://nginx.org/download/nginx-1.16.0.tar.gz 安装依赖 yum install gcc gcc-c++ pcre pcre-devel zlib zlib-devel openssl openssl-devel -y 解压包 tar xf nginx-1.16.0.tar.gz cd nginx-1.16.0 预编译 预编译主要是用来检查系统环境是否满足安装软件包的条件， 并生成Makefile文件，该文件为编译、安装、升级nginx指明了相应参数。 ./configure --help 可以查看预编译参数 --prefix 指定nginx编译安装的目录； --user=*** 指定nginx的属主 --group=*** 指定nginx的属主与属组 --with-*** 指定编译某模块 --without-** 指定不编译某模块 --add-module 编译第三方模块 开始预编译 ./configure --prefix=/usr/local/nginx --user=nginx --group=nginx make clean : 重新预编译时，通常执行这条命令删除上次的编译文件 make build : 编译，默认参数，可省略build参数 make install : 安装 make modules : 编译模块 make upgrade : 在线升级 编译&安装 make & make install 查看版本 /usr/local/nginx/sbin/nginx -v nginx version: nginx/1.16.0 启动 nginx /usr/local/nginx/sbin/nginx 检查进程及端口 # 查看进程： [root@localhost ~]# ps -ef|grep nginx # 查看端口 [root@localhost ~]# netstat -ntlp|grep 80 可以看到端口及进程表示 nginx WEB 服务已经搭建成功！ nginx 常用命令 使用/usr/local/nginx/sbin/nginx -h 命令查看可用参数： [root@localhost ~]# /usr/local/nginx/sbin/nginx -h nginx version: nginx/1.16.0 Usage: nginx [-?hvVtTq][-s signal] [-c filename][-pprefix] [-g directives] Options: -?,-h : this help -v : show version and exit -V : show version and configure options then exit -t : test configuration and exit -T : test configuration, dump it and exit -q : suppress non-error messages during configuration testing -s signal : send signal to a master process: stop,quit, reopen, reload -p prefix : set prefix path (default:/usr/local/nginx/) -c filename : set configuration file (default:conf/nginx.conf) -g directives : set global directives out of configuration file 命令解读 -v 可查看nginx的版本。 -V 可查看nginx的详细信息，包括编译的参数。 -t 可用来测试nginx的配置文件的语法错误。 -T 可用来测试nginx的配置文件语法错误，同时还可以通过重定向备份nginx的配置文件。 -q 如果配置文件没有错误信息时，不会有任何提示，如果有错误，则提示错误信息，与-t配合使用。 -s 发送信号给master处理： stop 立刻停止nginx服务，不管请求是否处理完 quit 优雅的退出服务，处理完当前的请求退出 reopen 重新打开日志文件，原日志文件要提前备份改名。 reload 重载配置文件 -p 设置nginx家目录路径，默认是编译时的安装路径 -c 设置nginx的配置文件，默认是家目录下的配置文件 -g 设置nginx的全局变量，这个变量会覆盖配置文件中的变量。 命令演示 如果觉得每次都需要输入绝对路径执行命令麻烦，可以通过以下几种方法实现直接使用 nginx 命令。 1、做软连接： ln -s /usr/local/nginx/sbin/* /usr/local/sbin 然后重新读取下配置文件 . /etc/profile ps:软连接做在PATH路径是第一位，因为yum安装的在/usr/sbin/目录下，which安装PATH的顺序找到第一个，就不找了。 2、配置环境变量： echo \"export PATH=/usr/local/nginx/sbin:$PATH\" > /etc/profile.d/nginx.sh 然后重新读取下配置文件 source /etc/profile ps:最好写在$PATH前面，否则，如果安装了yum版的nginx,直接执行nginx会启动yum版的nginx，因为which nginx，会先找到/usr/sbin/nginx文件 3、设置别名： alias nginx='/usr/local/nginx/sbin/nginx' ps:which优先找别名 启动 nginx 立即停止 nginx nginx -s stop 优雅停止 nginx nginx -s quit 重新打开日志文件 该命令可用于日志切割，定期执行。 [root@localhost logs]# ls access.log error.log nginx.pid [root@localhost logs]# mv access.log{,.bak} [root@localhost logs]# ls access.log.bak error.log nginx.pid [root@localhost logs]# /usr/local/nginx/sbin/nginx -s reopen [root@localhost logs]# ls access.log access.log.bak error.log nginx.pid 重载配置文件 修改工作进程数，重启服务，对比前后进程数 [root@localhost logs]# ps -ef|grep nginx root 2685 1 0 23:56 ? 00:00:00 nginx:master process /usr/local/nginx/sbin/nginx nginx 2686 2685 0 23:56 ? 00:00:00 nginx:worker process root 2691 2532 0 23:57 pts/1 00:00:00 grep --color=auto nginx [root@localhost logs]# vim /usr/local/nginx/conf/nginx.conf [root@localhost logs]# /usr/local/nginx/sbin/nginx -s reload [root@localhost logs]# ps -ef|grep nginx root 2685 1 0 23:56 ? 00:00:00 nginx:master process /usr/local/nginx/sbin/nginx nginx 2694 2685 0 23:58 ? 00:00:00 nginx:worker process nginx 2695 2685 0 23:58 ? 00:00:00 nginx:worker process nginx 2696 2685 0 23:58 ? 00:00:00 nginx:worker process root 2698 2532 0 23:58 pts/1 00:00:00 grep --color=auto nginx 启动指定的配置文件 在/data/目录下拷贝一份 nginx 的配置文件，然后修改用户名为 www。 注意：配置文件中引用的其他配置文件路径也要做一个修改 [root@localhost logs]# cp /usr/local/nginx/conf/nginx.conf /data/ [root@localhost logs]# vim /data/nginx.conf [root@localhost logs]# /usr/local/nginx/sbin/nginx -c /data/nginx.conf [root@localhost logs]# ps -ef|grep nginx root 2736 1 0 00:05 ? 00:00:00 nginx:master process /usr/local/nginx/sbin/nginx -c /data/nginx.conf www 2737 2736 0 00:05 ? 00:00:00 nginx:worker process www 2738 2736 0 00:05 ? 00:00:00 nginx:worker process www 2739 2736 0 00:05 ? 00:00:00 nginx:worker process root 2741 2532 0 00:05 pts/1 00:00:00 grep --color=auto nginx 设置全局变量 通过设置全局变量，让 nginx 在前端运行。 [root@localhost logs]# /usr/local/nginx/sbin/nginx -g \"daemon off;\" 现在当前 nginx 在前端运行， 输入 ctrl +c，则 nginx 就退出了。 可以使用 ctrl +z 放置后台运行。 nginx 配置文件路径 不同安装方式，nginx 的文件存放路径也有所不同。 源码安装配置文件路径 在安装目录下的 conf 目录下，比如我的安装目录是/usr/local/nginx，那么他的配置文件就在/usr/local/nginx/conf 目录下 yum 安装配置文件路径 在/etc/nginx/目录（主配置文件）与/etc/nginx/conf.d 目录下。 nginx 配置文件的结构 通常源码安装的 nginx 的配置文件，会是下面这种结构，yum 安装的有细微差异（大致是一样的，只是 server 是通过 include 引用的独立配置文件）。 ... events { ... } http { ... server { .... location / { root html; ... } } } nginx 的配置指令可以分为两大类：指令块与单个指令。 指令块就是像 events，http，server 等； 单独指令就是像 root html;这样的。 nginx 规定指令块可以嵌套，如 http 块中可以嵌套 server 指令，server 块中可以嵌套 location 指令，指令可以同时出现在不同的指令块，如 root 指令可以同时出现在 http、server 和 location 指令块，需要注意的是在 location 中定义的指令会覆盖 server，http 的指令。 By xiaobei，使用知识共享 署名-相同方式共享 4.0协议发布            此页面修订于： 2020-08-15 09:39:51 "},"book/technology/linux/Special-lecture/nginx配置文件解读及常用模块.html":{"url":"book/technology/linux/Special-lecture/nginx配置文件解读及常用模块.html","title":"nginx 配置文件解读及常用模块","keywords":"","body":"解析配置文件 全局配置 user nobody; worker_processes 1; #error_log logs/error.log; #error_log logs/error.log notice; #error_log logs/error.log info; #pid logs/nginx.pid; events { use epoll; worker_connections 1024; } user :指定 nginx 的工作进程的用户及用户组，默认是 nobody 用户。 worker_processes :指定工作进程的个数，默认是 1 个。具体可以根据服务器 cpu 数量进行设置，比如 cpu 有 4 个，可以设置为 4。如果不知道 cpu 的数量，可以设置为 auto。nginx 会自动判断服务器的 cpu 个数，并设置相应的进程数。 error_log :设置 nginx 的错误日志路径，并设置相应的输出级别。如果编译时没有指定编译调试模块，那么 info 就是最详细的输出模式了。如果有编译 debug 模块，那么 debug 时最为详细的输出模式。这里设置为默认就好了。 pid :指定 nginx 进程 pid 的文件路径。 events :这个指令块用来设置工作进程的工作模式以及每个进程的连接上限。 use :用来指定 nginx 的工作模式，通常选择 epoll，除了 epoll，还有select,poll。 worker_connections :定义每个工作进程的最大连接数，默认是1024。 ps:进程的最大连接数受 Linux 系统进程的最大打开文件数限制。 修改文件描述符方式： 临时生效： ulimit -n 65535 在压测的时候，如果遇到报错 apr_socket_recv: Connection reset by peer (104)： 解决办法： # 临时解决： 加一个-r参数，避免因为套接字错误退出，但是影响测试结果。 # 根本解决： # vim /etc/sysctl.conf net.ipv4.tcp_syncookies = 0 然后执行：sysctl -p http 指令块 http { include mime.types; default_type application/octet-stream; charset utf-8; #log_format main '$remote_addr - $remote_user [$time_local] \"$request\" ' # '$status $body_bytes_sent \"$http_referer\" ' # '\"$http_user_agent\" \"$http_x_forwarded_for\"'; #access_log logs/access.log main; Sendfile on; tcp_nopush on; tcp_nodelay on; #keepalive_timeout 0; keepalive_timeout 65; keepalive_requests 100; #gzip on; server { ... location { root html; ... } } } include mime.types; 定义数据类型 如果用户请求xiaobei.png，服务器上有xiaobei.png这个文件，后缀名是png； 根据mime.types，这个文件的数据类型应该是image/png； 将Content-Type的值设置为image/png，然后发送给客户端 default_type :设定默认类型为二进制流，也就是当文件类型未定义时使用这种方式，例如在没有配置PHP环境时，Nginx是不予解析的，此时，用浏览器访问PHP文件就会出现下载窗口。 charset utf-8; 解决中文字体乱码 log_format :定义日志文件格式，并默认取名为main，可以自定义该名字。也可以通过添加，删除变量来自定义日志文件的格式。 access_log :定义访问日志的存放路径，并且通过引用log_format所定义的main名称设置其输出格式。 sendfile on :用于开启高效文件传输模式。直接将数据包封装在内核缓冲区，然后返给客户，将tcp_nopush和tcp_nodelay两个指令设置为on用于防止网络阻塞； keepalive_timeout 65 :设置客户端连接保持活动的超时时间。在超过这个时间之后，服务器会关闭该连接。 keepalive_requests 100 :设置nginx在保持连接状态最多能处理的请求数，到达请求数，即使还在保持连接状态时间内，也需要重新连接。 提示：可以用netstat -ntlpa |grep 80 查看链接状态 gzip on :开启压缩功能，减少文件传输大小，节省带宽。 gzip_min_length 1k; 最小文件压缩，1k起压。 gzip_types text/plain text/xml; 压缩文件类型 gzip_comp_level 3; 压缩级别，默认是1。 server 指令块 server { listen 80; server_name localhost; #charset koi8-r; #access_log logs/host.access.log main; index index.html index.htm; location / { root html; ... } #error_page 404 /404.html; error_page 500 502 503 504 /50x.html; location = /50x.html { root html; } #location ~ \\.php$ { ... #} #location ~ /\\.ht { # deny all; #} } server :用来定义虚拟主机。 listen :设置监听端口，默认为 80 端口 server_name :域名，多个域名通过逗号隔开 Charset :设置网页的默认编码格式 access_log :指定该虚拟主机的独立访问日志，会覆盖前面的全局配置。 index :设置默认的索引文件 location :定义请求匹配规则。 error_page :定义访问错误返回的页面，凡是状态码是 500 502 503 504 都会返回这个页面。 location 指令块 #location ~ \\.php$ { # root html; # fastcgi_pass 127.0.0.1:9000; # fastcgi_index index.php; # fastcgi_param SCRIPT_FILENAME /scripts$fastcgi_script_name; # include fastcgi_params; #} # deny access to .htaccess files, if Apache's document root # concurs with nginx's one # #location ~ /\\.ht { # deny all; #} location ~ \\.php\\$ :凡是以 php 结尾文件，都会匹配到这条规则。 root :php 文件存放的目录 fastcgi_pass :指定 php-fpm 进程管理的 ip 端口或者 unix 套接字 fastcgi_index :指定 php 脚本目录下的索引文件 fastcgi_param :指定传递给 FastCGI 服务器的参数 location ~ /\\.ht :凡是请求类似.ht 资源，都拒绝 热部署(方案一) 查看原编译参数 # 升级一般是添加新的模块，或者升级版本，所以要参考以前编译的模块，如果不添加，那么以前的模块就不能使用了 [root@node3 ~]# /usr/local/nginx/sbin/nginx -V 预编译/编译/安装 ./configure --prefix=/usr/local/nginx make && make install 直接升级 make upgrade 热部署(方案二) 查看原编译参数(同上) # 升级一般是添加新的模块，或者升级版本，所以要参考以前编译的模块，如果不添加，那么以前的模块就不能使用了 [root@node3 ~]# /usr/local/nginx/sbin/nginx -V 预编译&编译&安装 ./configure --prefix=/usr/local/nginx make && make install 生成新的 master 进程 kill -USR2 `cat /usr/local/nginx/logs/nginx.pid` [root@node3 nginx-1.16.0]# ps -ef |grep \"[n]ginx\" root 8054 1 0 21:07 ? 00:00:00 nginx:master process /usr/local/nginx/sbin/nginx nginx 8097 8054 0 21:09 ? 00:00:00 nginx:worker process nginx 8098 8054 0 21:09 ? 00:00:00 nginx:worker process root 8134 8054 0 21:13 ? 00:00:00 nginx:master process /usr/local/nginx/sbin/nginx nginx 8135 8134 0 21:13 ? 00:00:00 nginx:worker process nginx 8136 8134 0 21:13 ? 00:00:00 nginx:worker process 优雅退出老 worker 进程 # 向老的master进程发信号： [root@node3 nginx-1.16.0]# kill -WINCH 8054 [root@node3 nginx-1.16.0]# ps -ef |grep \"[n]ginx\" root 8054 1 0 21:07 ? 00:00:00 nginx:master process /usr/local/nginx/sbin/nginx root 8134 8054 0 21:13 ? 00:00:00 nginx:master process /usr/local/nginx/sbin/nginx nginx 8135 8134 0 21:16 ? 00:00:00 nginx:worker process nginx 8136 8134 0 21:16 ? 00:00:00 nginx:worker process 抉择 回滚 重新拉起老的 worker 进程： [root@node3 nginx-1.16.0]# kill -HUP 8054 [root@node3 nginx-1.16.0]# ps -ef |grep \"[n]ginx\" root 8054 1 0 21:07 ? 00:00:00 nginx:master process /usr/local/nginx/sbin/nginx root 8134 8054 0 21:13 ? 00:00:00 nginx:master process /usr/local/nginx/sbin/nginx nginx 8135 8134 0 21:16 ? 00:00:00 nginx:worker process nginx 8136 8134 0 21:16 ? 00:00:00 nginx:worker process nginx 8154 8054 1 21:19 ? 00:00:00 nginx:worker process nginx 8155 8054 1 21:19 ? 00:00:00 nginx:worker process 退出新的 master 进程： [root@node3 nginx-1.16.0]# kill -QUIT `cat /usr/local/nginx/logs/nginx.pid` [root@node3 nginx-1.16.0]# ps -ef |grep \"[n]ginx\" root 8054 1 0 21:07 ? 00:00:00 nginx:master process /usr/local/nginx/sbin/nginx nginx 8154 8054 0 21:19 ? 00:00:00 nginx:worker process nginx 8155 8054 0 21:19 ? 00:00:00 nginx:worker process 换回 nginx 文件: # 先删除新的nginx二进制文件： rm -rf /usr/local/nginx/sbin/nginx # 还原老的nginx 二进制文件： mv /usr/local/nginx/sbin/nginx.old /usr/local/nginx/sbin/nginx 新生 # 经过一段时间测试，服务器没问题，退出老的master: [root@node3 nginx-1.16.0]# kill -QUIT 8054 [root@node3 nginx-1.16.0]# ps -ef |grep \"[n]ginx\" root 8134 1 0 21:24 ? 00:00:00 nginx:master process /usr/local/nginx/sbin/nginx nginx 8135 8134 0 21:24 ? 00:00:00 nginx:worker process nginx 8136 8134 0 21:24 ? 00:00:00 nginx:worker process 常用模块 access 模块 访问控制模块 ，该模块可以实现简单的防火墙功能，过滤特定的主机。这个模块在我们编译 nginx 时会默认编译进 nginx 的二进制文件中。 语法: Syntax: allow address | CIDR | unix: | all; Default: — Context: http, server, location, limit_except Syntax: deny address | CIDR | unix: | all; Default: — Context: http, server, location, limit_except allow: 允许访问的 IP 或者网段。 deny: 拒绝访问的 ip 或者网段。 从语法上看，它允许配置在 http 指令块中，server 指令块中还有 locatio 指令块中，这三者的作用域有所不同。 如果配置在 http 指令段中，将对所有 server(虚拟主机)生效； 配置在 server 指令段中，对当前虚拟主机生效； 配置在 location 指令块中，对匹配到的目录生效。 ps: 如果 server 指令块，location 指令块没有配置限制指令，那么将会继承 http 的限制指令，但是一旦配置了会覆盖 http 的限制指令。或者说作用域小的配置会覆盖作用域大的配置。 http 指令块配置 对单 ip 进行限制：在 http 指令块下配置单 ip 限制； http { include mime.types; default_type application/octet-stream; # 限制192.168.115.132这个ip访问 deny 192.168.115.132; ... } ps: 配置完记得重载配置文件。 /usr/local/nginx/sbin/nginx -s reload 在自己服务上访问 [root@localhost ~]# curl -I 192.168.115.129 HTTP/1.1 200 OK Server: nginx/1.16.0 Date: 01 08 2020 02:24:19 GMT Content-Type: text/html 在 192.168.115.132 服务器上访问 [root@localhost ~]# curl -I 192.168.115.129 HTTP/1.1 403 Forbidden Server: nginx/1.16.0 可以看到只对 192.168.115.132 这个 ip 生效了，如果有配置虚拟主机，那么这个 ip 将都不能访问。 对网段进行限制： 如果想让整个网段都不能访问，只需要将这个 ip 改为网段即可。 http { include mime.types; default_type application/octet-stream; # 将ip改为网段 deny 192.168.115.0/24; ... } 在自己服务器上访问 [root@localhost ~]# curl -I 192.168.115.129 HTTP/1.1 403 Forbidden Server: nginx/1.16.0 在 192.168.115.129 上访问 [root@localhost ~]# curl -I 192.168.115.129 HTTP/1.1 403 Forbidden Server: nginx/1.16.0 可以看到都不能访问了，对整个网段的限制已生效。 server 指令块配置 配置方法都是一样的，只是作用范围不同。 对单 ip 进行限制： server { listen 80; server_name localhost; deny 192.168.115.132; ... } 在自己服务上访问 [root@localhost ~]# curl -I 192.168.115.129 HTTP/1.1 200 OK Server: nginx/1.16.0 Date: 01 08 2020 02:24:19 GMT Content-Type: text/html 在 192.168.115.132 服务器上访问 [root@localhost ~]# curl -I 192.168.115.129 HTTP/1.1 403 Forbidden Server: nginx/1.16.0 限制网段同上 location 指令块配置 在 location 指令块配置访问控制。 这种配置是最多的，因为有时候我们要限制用户对某些文件或者目录的访问，这些文件通常是比较重要的或者私密的。 location /secret { deny 192.168.115.132; } 创建目录以及测试文件： [root@localhost ~]# mkdir -p /usr/local/nginx/html/secret [root@localhost ~]# echo \"this is secret\" > /usr/local/nginx/html/secret/index.html 在本机访问 [root@localhost ~]# curl 192.168.115.129/secret/index.html this is secret 白名单设置 通过指定限制某个 IP 或者网段，这些形式是黑名单式的。 但如果想某些服务或者文件只针对于某些 IP 或者网段（通常是内网）开放，那么可以使用白名单，默认拒绝，指定的放行。 实例： location /secret { allow 192.168.115.132; deny all; } 在本机访问 [root@localhost ~]# /usr/local/nginx/sbin/nginx -s reload [root@localhost ~]# curl 192.168.115.129/secret/index.html this is secret 在 192.168.115.132 上访问 可以看到，现在只有自己可以访问了，其他都被拒绝了。 auth_basic 模块 用户认证模块，对访问目录进行加密，需要用户权限认证： 这个功能特性是由 ngx_http_auth_basic_module 提供的，默认编译 nginx 时会编译好，主要有以下两个指令。 语法： Syntax: auth_basic string | off; Default: auth_basic off; Context: http, server, location, limit_except Syntax: auth_basic_user_file file; Default: — Context: http, server, location, limit_except 认证的配置可以在 http 指令块，server 指令块，location 指令块配置。 auth_basic string ：定义认证的字符串，会通过响应报文返给客户端，也可以通过这个指令关闭认证。 auth_basic_user_file file ：定义认证文件。 对指定目录加密 # 对匹配目录加密： location /img { auth_basic \"User Auth\"; auth_basic_user_file /usr/local/nginx/conf/auth.passwd; } auth_basic 设置名字 auth_basic_user_file 用户认证文件放置路径 生成认证文件： yum install httpd-tools -y htpasswd -c /usr/local/nginx/conf/auth.passwd admin 输入两次密码确定。 重启服务后，访问验证： 现在当我们访问 img 目录时，需要输入用户名及密码。 它不仅可以设置访问指定目录时认证，还可以直接在访问首页时认证。 如果需要关闭可以使用 auth_basic off;或者直接将这两段注释掉。 htpasswd 命令工具： htpasswd(选项)(参数) 选项 -c：创建一个加密文件； -m：默认采用MD5算法对密码进行加密； -d：采用CRYPT算法对密码进行加密； -p：不对密码进行进行加密，即明文密码； -s：采用SHA算法对密码进行加密； -b：在命令行中一并输入用户名和密码而不是根据提示输入密码； -D：删除指定的用户。 添加用户名及密码： htpasswd -b /usr/local/nginx/conf/auth.passwd xiaobei xiaobei666 更新密码： htpasswd -D /usr/local/nginx/conf/auth.passwd xiaobei htpasswd -b /usr/local/nginx/conf/auth.passwd xiaobei xiaobei123 对首页加密 # 对匹配目录加密： location / { auth_basic \"User Auth\"; auth_basic_user_file /usr/local/nginx/conf/auth.passwd; } stub_status 模块 状态查看模块 ，该模块可以 输出 nginx 的基本状态信息 。 语法： Syntax: stub_status; Default: — Context: server, location 配置 location = /status { stub_status; allow 192.168.115.132; deny all; } Active connections:当前状态，活动状态的连接数 accepts：统计总值，已经接受的客户端请求的总数 handled：统计总值，已经处理完成的客户端请求的总数 requests：统计总值，客户端发来的总的请求数 Reading：当前状态，正在读取客户端请求报文首部的连接的连接数 Writing：当前状态，正在向客户端发送响应报文过程中的连接数 Waiting：当前状态，正在等待客户端发出请求的空闲连接数 referer 模块 该模块可以进行防盗链设置。 盗链的含义是网站内容本身不在自己公司的服务器上，而通过技术手段，直接调用其他公司的服务器网站数据，而向最终用户提供此内容。 语法： Syntax: valid_referers none | blocked | server_names |string ...; Default: — Context: server, location 配置防盗链 在 129 服务器上配置 nginx 防盗链： location ~* \\.(gif|jpg|png|swf|flv)$ { valid_referers none blocked xiaobei.net *.koala.net; root /usr/share/nginx/html; if ($invalid_referer) { return 403; } } valid_referers 表示合法的referers设置 none： 表示没有referers，直接通过浏览器或者其他工具访问。 blocked： 表示有referers，但是被代理服务器或者防火墙隐藏； xiaobei.net： xiaobei.net访问的referers； *.koala.net: 表示通过*.koala.net访问的referers，*表示任意host主机。 防盗链测试 找另外一台测试服务器，基于 Nginx 发布如下 test.html 页面，代码如下，去调用 129 官网的 test.png 图片，由于 129 官网设置了防盗链，所以无法访问该图片。 welcome to nginx By xiaobei，使用知识共享 署名-相同方式共享 4.0协议发布            此页面修订于： 2020-08-15 09:39:51 "},"book/technology/linux/Special-lecture/nginx服务器location、rewite规则.html":{"url":"book/technology/linux/Special-lecture/nginx服务器location、rewite规则.html","title":"nginx 服务器 location、rewite 规则","keywords":"","body":"Location 基础知识 概念 我们可以通过配置 Location 指令块，来决定客户端发过来的请求 URI 如何处理。 语法 Syntax: location [ = | ~ | ~* | ^~ ] uri { ... } location @name { ... } Default: — Context: server, location location 配置可以有两种配置方法，可以在 server 指令块和 location 指令块配置。 1、修饰符 + uri（资源路径） 2、@ + name 修饰符 = ：精确匹配（必须全部相等） ~ ：大小写敏感（正则表达式） ~*：忽略大小写（正则表达式），这里要注意忽略大小写的意思是请求的字符大小写都可以，但是不会进行大小转换，请求的大小写对应的文件必须存在。 ^~ ：只需匹配uri部分 @ ：内部服务跳转 Location 配置实例 精准匹配 =，精准匹配，一般是匹配某个具体文件。 location = /index.html { [ configuration ] } # 则匹配到`http://www.xiaobei.com/index.html`这种请求。 大小写敏感匹配 ~，大小写敏感（正则表达式）。 location ~ /XIAOBEI/ { [ configuration ] } #请求示例 #http://www.xiaobei.com/XIAOBEI/ [成功] #http://www.xiaobei.com/xiaobei/ [失败] 大小写不敏感匹配 ~*，大小写忽略（正则表达式）。 location ~* /xiaobei.html { [ configuration ] } # 则会忽略 uri 部分的大小写 #http://www.xiaobei.com/xiaobei.html [成功] 可以成功匹配，但是目录中要xiaobei.html文件 #http://www.xiaobei.com/XIAOBEI.html [成功] 可以成功匹配，但是目录中要XIAOBEI.html文件 指定后缀匹配 匹配以 gif、jpg、jpeg 结尾的文件 location ~* \\.(gif|jpg|jpeg)$ { [ configuration ] } #http://www.xiaobei.com/img/xiaobei.jpg [成功] 忽略正则匹配 ^~，只匹配以 uri 开头，匹配成功以后，会停止搜索后面的正则表达式匹配。 location ^~ /img/ { [ configuration ] } #以 /img/ 开头的请求，都会匹配上 #http://www.xiaobei.com/img/xiaobei.jpg [成功] #http://www.xiaobei.com/img/xiaobei.png [成功] 如果配置了忽略正则匹配，那么所有请求 /img/ 下的图片会被上面的处理，因为 ^~指令匹配到了，则不检查正则表达式。对比这两个 location，可以设置不同目录，相同文件进行实验。 Location 优先级 完整范例： 这里有一简短的localtion配置： location / { echo \"this is $request_uri\"; } location ~* \\.(jpg|png) { echo \"this is ~* \\.(jpg|png)\"; } location ~ \\.(jpg|png) { echo \"this is ~ \\.(jpg|png)\"; } location ^~ /img/xiaobei.jpg { echo \"this is ^~ /img/xiaobei.jpg\"; } location = /img/xiaobei.jpg { echo \"this is = /img/xiaobei.jpg\"; } 如果客户端的请求是：curl 192.168.115.129/img/xiaobei.jpg 那么按照匹配规则顺序应该是这样的： 取出 uri：/img/xiaobei.jpg 去匹配 localtion 规则，查找有没有 = /img/xiaobei.jpg 的规则，有则停止匹配。 [root@localhost ~]# curl 192.168.115.129/img/xiaobei.jpg this is = /img/xiaobei.jpg 将 location = /img/xiaobei.jpg 规则注释，继续查找有没有 ^~ /img/的规则。 [root@www ~]# curl 192.168.115.129/img/xiaobei.jpg this is ^~ /img/xiaobei.jpg 将 location ^~ /img/注释，这是它会去查找有没有正则匹配规则。 location / { echo \"this is $request_uri\"; } location ~* \\.(jpg|png)$ { echo \"this is ~* \\.(jpg|png)\"; } location ~ \\.(jpg|png)$ { echo \"this is ~ \\.(jpg|png)\"; } #location ^~ /img/xiaobei.jpg { # echo \"this is ^~ /img/xiaobei.jpg\"; #} #location = /img/xiaobei.jpg { # echo \"this is = /img/xiaobei.jpg\"; #} 其中，第二个和的第三个规则都是正则，这时会按照至上而下的顺序匹配。 [root@localhost ~]# curl 192.168.129.115/img/xiaobei.jpg this is ~* \\.(jpg|png) 其他的都注释后，因为优先匹配规则都没有找到，最后匹配到/img/规则 [root@localhost ~]# curl 192.168.115.129/img/xiaobei.jpg this is /img/xiaobei.jpg rewrite 规则 Nginx 的 rewrite 功能需要 pcre 软件的支持，即通过 perl 兼容正则表达式语句进行规则匹配的。 默认参数编译 nginx 就会支持 rewrite 的模块，但是也必须要 pcre 的支持。 rewrite 是实现 URL 重写的关键指令，根据 regex（正则表达式）部分内容，重定向到 replacement，结尾是 flag 标记。 rewrite 语法 rewrite [flag]; 正则 替代内容 flag标记 正则：perl兼容正则表达式语句进行规则匹配 替代内容：将正则匹配的内容替换成replacement flag标记：rewrite支持的flag标记 # flag标记说明： last #本条规则匹配完成终止当前location的规则，继续向下匹配新的location URI规则 break #本条规则匹配完成即终止，不再匹配后面的任何规则 redirect #返回302临时重定向，浏览器地址会显示跳转后的URL地址，关闭服务，无法重定向。 permanent #返回301永久重定向，浏览器地址栏会显示跳转后的URL地址，关闭服务，依然可以重定向，清除缓存失效。 rewrite 实例 实现域名跳转 #方案一： server { listen 80; server_name xiaobei.com; rewrite ^/(.*)$ http://www.xiaobei.com/$1 permanent; } server { listen 80; server_name www.xiaobei.com; location / { root /data/www/; index index.html index.htm; } } #方案二： server { listen 80; server_name www.xiaobei.com xiaobei.com; if ( $host != 'www.xiaobei.com' ) { rewrite ^/(.*)$ http://www.xiaobei.com/$1 permanent; } location / { root /data/www/; index index.html index.htm; } } #ps：本地需要做hosts解析 #192.168.115.129 www.xiaobei.com xiaobei.com 实现不同终端跳转 server { listen 80; server_name xiaobei.com www.xiaobei.com; root /usr/share/nginx/html/test; if ( $http_user_agent ~* \"iphone|android\") { rewrite ^/(.*)$ http://m.xiaobei.com/$1; } index index.html; } server { listen 80; server_name m.xiaobei.com; root /data/www/m; index index.html; location / { default_type text/html; return 200 \"this is iphone|android html\"; } } 实现浏览器的语言跳转 # 根据浏览器的语言跳转到指定url: server { listen 80; server_name xiaobei.com www.xiaobei.com; root /usr/share/nginx/html/test; index index.html; location / { if ( $http_accept_language ~ \"^zh-CN\" ) { rewrite ^/(.*) /zh/$1 ; } if ( $http_accept_language ~ \"^en\" ) { rewrite ^/(.*) /en/$1 ; } root html; index index.html index.htm; } location ^~ /zh/ { root html/; index index.html; } location ^~ /en/ { root html/; index index.html; } } mkdir -p /usr/share/nginx/html/test/zh mkdir -p /usr/share/nginx/html/test/en echo \"this is 中文 \" > /usr/share/nginx/html/test/zh/index.html echo \"this is English \" > /usr/share/nginx/html/test/en/index.html 实现错误页面返回首页 error_page 404 =200 /index.html; 实现错误页面返回腾讯公益页面 error_page 404 =200 /404.html; vim /usr/local/nginx/html/404.html 公益404 By xiaobei，使用知识共享 署名-相同方式共享 4.0协议发布            此页面修订于： 2020-08-15 09:39:51 "},"book/technology/linux/Special-lecture/nginx服务器虚拟主机、反向代理.html":{"url":"book/technology/linux/Special-lecture/nginx服务器虚拟主机、反向代理.html","title":"nginx 服务器虚拟主机、反向代理","keywords":"","body":"Nginx 虚拟主机 虚拟主机作用 虚拟主机提供了在同一台服务器上运行多个网站的功能。 虚拟主机的三种模式 基于多域名方式配置虚拟主机 基于多端口配置虚拟主机 基于多 ip 配置虚拟主机 基于多域名的虚拟主机是最常见的一种虚拟主机。 只需配置你的 DNS 服务器，将每个主机名映射到正确的 IP 地址，然后配置 Nginx 服务器，令其识别不同的主机名就可以了。 网域名称系统（DNS，Domain Name System，将域名和IP地址相互映射的一个分布式数据库）是因特网的一项核心服务，它作为可以将域名和IP地址相互映射的一个分布式数据库，能够使人更方便地访问互联网，而不用去记住能够被机器直接读取的IP地址数串。 参考： https://baike.baidu.com/item/%E5%9F%9F%E5%90%8D/86062?fr=aladdin 基于多端口的虚拟主机，可以使用同一个 ip，通过访问不同的端口来访问。 基于多 IP 的虚拟主机可以通过添加多个网卡或者在一块物理网卡上绑定多个 IP 地址来实现 ps:如果没有特殊要求，最好还是使用基于多域名的虚拟主机。 多域名配置虚拟主机 配置 hosts 文件 hosts 文件：在本机计算机上面，配置本地的 ip 地址和域名映射关系，通常用于测试。 Windows 本地 hosts 文件 C:\\Windows\\System32\\drivers\\etc\\hosts 192.168.115.129 www.xiaobei.com Linux 本地 hosts 文件 vim /etc/hosts 192.168.115.129 www.xiaobei.com 创建虚拟主机配置文件 #在http指定块中添加： include /usr/local/nginx/conf/vhost/*.conf; #创建配置主机配置文件 mkdir -p /usr/local/nginx/conf/vhost vim /usr/local/nginx/conf/vhost/www.xiaobei.com.conf server { listen 80; server_name www.xiaobei.com; location / { root /usr/local/nginx/html/xiaobei; index index.html index.htm; } } vim /usr/local/nginx/conf/vhost/www.xb.com.conf server { listen 80; server_name www.xb.com; location / { root /usr/local/nginx/html/xb; index index.html index.htm; } } 多端口配置虚拟主机 server { listen 8080; server_name www.xiaobei.com; location / { root /usr/share/nginx/html/xiaobei; index index.html; } } 多 IP 配置虚拟主机 cp /etc/sysconfig/network-scripts/ifcfg-ens32{,:1} vim /etc/sysconfig/network-scripts/ifcfg-ens32:1 #修改以下信息: NAME=\"ens32:1\" DEVICE=\"ens32:1\" IPADDR=192.168.115.129 # 重启服务： systemctl restart network server { listen 192.168.115.129:80; server_name www.xiaobei.com; location / { root /usr/share/nginx/html/xiaobei; index index.html; } } #重启nginx服务： systemctl restart nginx Nginx 反向代理 反向代理概念 反向代理是 nginx 的一个重要功能，在编译安装时会默认编译该模块。在配置文件中主要配置 proxy_pass 指令。 代理服务器接受客户端的请求，然后把请求代理给后端真实服务器进行处理，然后再将服务器的响应结果返给客户端。 反向代理作用 与正向代理（正向代理主要是代理客户端的请求）相反，反向代理主要是代理服务器返回的数据，所以它的作用主要有以下两点： 可以防止内部服务器被恶意攻击（内部服务器对客户端不可见）。 为负载均衡和动静分离提供技术支持。 反向代理语法 Syntax: proxy_pass URL; Default: — Context: location, if in location, limit_except 代理服务器的协议，可支持 http 与 https。 地址可以指定为域名或 IP 地址，以及可选端口。 例如： proxy_pass http://192.168.115.129; proxy_pass http://192.168.115.129:8080; proxy_pass http://localhost:9000/uri/; 实例一 location 和 proxy_pass 都不带 uri 路径。 代理服务器：192.168.115.129 后端服务器：192.168.115.132 #代理服务器的简单配置： location / { proxy_pass http://192.168.115.129; } # proxy_pass 转发请求给后端服务器 #后端服务器的配置： location / { echo $host; root html; index index.html index.htm; } # echo $host 这个主要是来看下后端接收到的Host是什么。 验证 [root@localhost ~]# curl 192.168.115.129 192.168.115.132 # 获取的请求Host是后端服务器ip，去掉该指令，验证请求结果。 [root@localhost ~]# curl 192.168.115.129 this is 132 page # 可以看到我们访问的是129，但是得到的结果是132的发布目录文件。 实例二 proxy_pass 没有设置 uri 路径，但是代理服务器的 location 有 uri，那么代理服务器将把客户端请求的地址传递给后端服务器。 # 代理服务器的配置： location /document/data/ { proxy_pass http://192.168.115.132; } # 后端服务器的配置： location / { # echo $host; root html/uri; index index.html index.htm; } 验证 [root@localhost ~]# mkdir -p /usr/local/nginx/html/uri/document/data/ [root@localhost ~]# echo \"this is /usr/local/nginx/html/uri/document/data/ test\" > /usr/local/nginx/html/uri/document/data/index.html [root@localhost ~]# curl 192.168.115.129/document/data/ this is /usr/local/nginx/html/uri/document/data/ test # 完整请求路径 是在后端服务器的/usr/local/nginx/html/uri 后追加客户端请求的路径 /document/data/ 实例三 如果proxy_pass 设置了 uri 路径，则需要注意，此时，proxy_pass 指令所指定的 uri 会覆盖 location 的 uri。 # 代理服务器的配置： location / { proxy_pass http://192.168.0.114/data/; } # 后端服务器的配置： location / { root html; index index.html index.htm; } 验证 [root@localhost ~]# mkdir -p /usr/local/nginx/html/data/ [root@localhost ~]# echo \"this is /usr/local/nginx/html/data test。\" > /usr/local/nginx/html/data/index.html [root@localhost ~]# curl 192.168.0.109 this is /usr/local/nginx/html/data test。 #这样看好像很正常，但是稍作修改。 这次加上 location 的 uri，后端服务器加个子目录： # 代理服务器的配置： location /document/ { proxy_pass http://192.168.0.114/data/; } # 后端服务器的配置： location / { #echo $host; root html; index index.html index.htm; } 再次验证 [root@localhost ~]# curl 192.168.115.129/document/ this is /usr/local/nginx/html/data test。 # 该路径还是 proxy_pass 指定的uri路径，与location 没有关系了！ 获取远程客户端真实 ip 地址 # 代理服务器配置： location / { proxy_pass http://192.168.0.114; proxy_set_header Host $host; proxy_set_header X-Real-IP $remote_addr; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; } # 后端服务器配置： log_format main '$remote_addr - $remote_user [$time_local] \"$request\" ' '$status $body_bytes_sent \"$http_referer\" ' '\"$http_user_agent\" \"$http_x_real_ip\" \"$http_x_forwarded_for\"'; access_log logs/access.log main; 缓存代理服务器实战 在代理服务器的磁盘中保存请求目标的内容，加快响应速度，减少应用服务器（后端服务器）上的资源开销，比如多客户端请求相同的资源，代理缓存命中后，对于应用服务器来说，只发生了一次资源调度。 而浏览器上的缓存配置，一般来说是用来减少本地 IO 的，请求目标的内容会存放在浏览器本地。 # 代理服务器配置： proxy_cache_path /data/nginx/cache max_size=10g levels=1:2 keys_zone=nginx_cache:10m inactive=10m use_temp_path=off; upstream nginx { server 192.168.0.114; } server { listen 80; server_name localhost; location / { root html; index index.html index.htm; proxy_pass http://nginx; proxy_set_header Host $host; proxy_set_header X-Real-IP $remote_addr; proxy_cache nginx_cache; proxy_cache_key $host$uri$is_args$args; proxy_cache_valid 200 304 302 1d; } } /data/nginx/cache #缓存资源存放路径 levels #设置缓存资源的递归级别，默认为levels=1:2，表示Nginx为将要缓存的资源生成的key从后依次设置两级保存。 key_zone #在共享内存中设置一块存储区域来存放缓存的key和metadata，这样nginx可以快速判断一个request是否命中或者未命中缓存，1m可以存储8000个key，10m可以存储80000个key max_size #最大cache空间，如果不指定，会使用掉所有diskspace，当达到配额后，会删除不活跃的cache文件 inactive #未被访问文件在缓存中保留时间，本配置中如果60分钟未被访问则不论状态是否为expired，缓存控制程序会删掉文件。inactive默认是10分钟。需要注意的是，inactive和expired配置项的含义是不同的，expired只是缓存过期，但不会被删除，inactive是删除指定时间内未被访问的缓存文件 use_temp_path #如果为off，则nginx会将缓存文件直接写入指定的cache文件中，而不是使用temp_path存储，official建议为off，避免文件在不同文件系统中不必要的拷贝 proxy_cache #启用proxy cache，并指定key_zone。如果proxy_cache off表示关闭掉缓存。 By xiaobei，使用知识共享 署名-相同方式共享 4.0协议发布            此页面修订于： 2020-08-15 09:39:51 "},"book/technology/linux/Special-lecture/nginx负载均衡.html":{"url":"book/technology/linux/Special-lecture/nginx负载均衡.html","title":"nginx 负载均衡","keywords":"","body":"nginx 负载均衡 负载均衡目的 将前端超高并发访问转发至后端多台服务器进行处理，解决单个节点压力过大，造成 Web 服务响应过慢，严重的情况下导致服务瘫痪，无法正常提 供服务的问题。 工作原理 负载均衡分为四层负载均衡和七层负载均衡： 四层负载均衡是工作在七层协议的第四层-传输层，主要工作是转发。 它在接收到客户端的流量以后通过修改数据包的地址信息（目标地址和端口和源地址）将流量转发到应用服务器。 七层负载均衡是工作在七层协议的第七层-应用层，主要工作是代理。 它首先会与客户端建立一条完整的连接并将应用层的请求流量解析出来，再按照调度算法选择一个应用服务器，并与应用服务器建立另外一条连接 将请求发送过去。 配置 7 层均衡 前端服务器： 192.168.1.6 后端服务器1：192.168.1.5 后端服务器2：192.168.1.7 这里后端服务器也可以通过配置虚拟主机实现 前端服务器主要配置 upstream 和 proxy_pass： upstream 主要是配置均衡池和调度方法。 proxy_pass 主要是配置代理服务器 ip 或服务器组的名字。 proxy_set_header 主要是配置转发给后端服务器的 Host 和前端客户端真实 ip。 配置前端 nginx # 在http指令块下配置upstream指令块(/etc/nginx/conf.d/default.conf) upstream web { server 192.168.1.5; server 192.168.1.7; } # 在location指令块配置proxy_pass server { listen 80; server_name localhost; location / { proxy_pass http://web; proxy_next_upstream error http_404 http_502; proxy_set_header Host $host; proxy_set_header X-Real-IP $remote_addr; } } # proxy_next_upstream error http_404 http_502; # 通过这个指令，可以处理当后端服务返回404等报错时，直接将请求转发给其他服务器，而不是把报错信息返回客户端。 # proxy_set_header Host $host; # 通过这个指令，把客户端请求的host，转发给后端。 # proxy_set_header X-Real-IP $remote_addr # 通过这个指令，把客户端的IP转发给后端服务器，在后端服务器的日志格式中，添加$http_x_real_ip即可获取原始客户端的IP了。 配置后端 nginx yum install nginx -y echo \"this is 1.5 page\" > /usr/share/nginx/html/index.html echo \"this is 1.7 page\" > /usr/share/nginx/html/index.htm 均衡方式 轮询 upstream web { server 192.168.1.5; server 192.168.1.7; } 访问前端 IP: [root@192 ~]# while true;do curl 192.168.1.6;sleep 2;done this is 1.5 page this is 1.7 page this is 1.5 page this is 1.7 page #可以看到后端服务器，非常平均的处理请求。 轮询加权重 upstream web { server 192.168.1.5 weight=3; server 192.168.1.7 weight=1; } 访问前端 IP: [root@192 ~]# while true;do curl 192.168.1.6;sleep 1;done this is 1.5 page this is 1.5 page this is 1.5 page this is 1.7 page this is 1.5 page this is 1.5 page this is 1.5 page this is 1.7 page #后端服务，根据权重比例处理请求，适用于服务器性能不均的环境。 最大错误连接次数 错误的连接由 proxy_next_upstream， fastcgi_next_upstream 等指令决定，且默认情况下，后端某台服务器出现故障了，nginx 会自动将请求再次转发给其他正常的服务器（因为默认 proxy_next_upstream errortimeout）。所以即使我们没有配这个参数，nginx 也可以帮我们处理 error 和 timeout 的响应，但是没法处理 404 等报错。 为了看清楚本质，可以先将 proxy_next_upstream 设置为 off，也就是不将失败的请求转发给其他正常服务器，这样我们可以看到请求失败的结果。 upstream web { server 192.168.1.5 weight=1 max_fails=3 fail_timeout=9s; #先将1.5这台nginx关了。 server 192.168.1.7 weight=1; } server { listen 80; server_name localhost; location / { proxy_pass http://web; #proxy_next_upstream error http_404 http_502; proxy_next_upstream off; proxy_set_header Host $host; proxy_set_header X-Real-IP $remote_addr; } } # 在这里，我们将超时时间设置为9s，最多尝试3次， 这里要注意，尝试3次，依然遵循轮询的规则，并不是一个请求，连接3次， 而是轮询三次，有3次处理请求的机会。 访问前端 IP: [root@192 ~]# while true;do curl -I 192.168.1.6 2>/dev/null|grep HTTP/1.1 ;sleep 3;done HTTP/1.1 502 Bad Gateway HTTP/1.1 200 OK HTTP/1.1 502 Bad Gateway HTTP/1.1 200 OK HTTP/1.1 502 Bad Gateway HTTP/1.1 200 OK HTTP/1.1 200 OK HTTP/1.1 200 OK HTTP/1.1 200 OK HTTP/1.1 502 Bad Gateway # 我们设置的超时时间为9s，我们是每3s请求一次。 我们可以看到后端一台服务器挂了后，请求没有直接转发给正常的服务器，而是直接返回了502。尝试三次后，等待9s，才开始再次尝试（最后一个 502）。 把 proxy_next_upstream 开启，再来访问看结果： upstream web { server 192.168.1.5 weight=1 max_fails=3 fail_timeout=9s; #先将1.5这台nginx关了。 server 192.168.1.7 weight=1; } server { listen 80; server_name localhost; location / { proxy_pass http://web; proxy_next_upstream error http_404 http_502; #proxy_next_upstream off; proxy_set_header Host $host; proxy_set_header X-Real-IP $remote_addr; } } 访问前端 IP： [root@192 ~]# while true;do curl -I 192.168.1.6 2>/dev/null|grep HTTP/1.1 ;sleep 3;done HTTP/1.1 200 OK HTTP/1.1 200 OK HTTP/1.1 200 OK HTTP/1.1 200 OK HTTP/1.1 200 OK HTTP/1.1 200 OK #可以看到现在没有502报错，请求都处理了。因为错误的响应码被 #proxy_next_upstream 获取，这次请求被转发给下一个正常的服务器了。 ip_hash 通过客户端 ip 进行 hash，再通过 hash 值选择后端 server 。 upstream web { ip_hash; server 192.168.1.5 weight=1 max_fails=3 fail_timeout=9s; server 192.168.1.7 weight=1; } server { listen 80; server_name localhost; location / { proxy_pass http://web; proxy_next_upstream error http_404 http_502; #proxy_next_upstream off; proxy_set_header Host $host; proxy_set_header X-Real-IP $remote_addr; } } 访问前端 IP： [root@192 ~]# while true;do curl 192.168.1.6;sleep 2;done this is 1.5 page this is 1.5 page this is 1.5 page ^C [root@192 ~]# curl 192.168.1.7 this is 1.7 page #可以看到1.7的服务是正常的，但是却不转发给1.7了，请求固定在了1.5的服务器上。 在使用负载均衡的时候会遇到会话保持的问题,常用的方法有: a、ip_hash，根据客户端的 IP，将请求分配到不同的服务器上; b、cookie，服务器给客户端下发一个 cookie，具有特定 cookie 的请求会分配给它的发布者。 url_hash 通过请求 url 进行 hash，再通过 hash 值选择后端 server upstream nginx_web { hash $request_uri consistent; server 192.168.75.128; server 192.168.75.135; } 根据响应时间均衡 fair 算法会根据后端节点服务器的响应时间来分配请求，时间短的优先分配 # 下载模块： wget https://github.com/gnosek/nginx-upstreamfair/archive/master.zip # 解压： unzip master.zip # 修改源码bug： sed -i 's/default_port/no_port/g' ngx_http_upstream_fair_module.c # 预编译： ./configure --prefix=/usr/local/nginx --addmodule=../echo-nginx-module --with-http_stub_status_module --add-module=../nginx-upstream-fair-master # 编译/安装： make && make install # 配置： upstream web { fair; server 192.168.1.5 weight=1 max_fails=3 fail_timeout=9s; server 192.168.1.7 weight=1; } 备用服务器 upstream web { server 192.168.1.5 weight=1 max_fails=3 fail_timeout=9s; server 192.168.1.7 weight=1 backup; } # 1.7的服务器做备用服务器，只有在1.5得服务器不能提供服务时，才会自动顶上,否则，默认是不提供服务的。 配置四层均衡 前端服务器：192.168.75.130 后端服务器1：192.168.75.128 后端服务器2：192.168.75.135 前端服务器主要配置 stream 和 upstream，注意该模块需要在预编译时指定，没有被默认编译进 nginx。 配置前端服务器 # 预编译： ./configure --prefix=/usr/local/nginx --addmodule=../echo-nginx-module --with-http_stub_status_module --with-stream # 编译/安装： make && make install # 在main全局配置stream： events { worker_connections 1024; } stream { upstream web { # 必须要指定ip加port server 192.168.75.128:80; server 192.168.75.135:80; } server { listen 80; # 连接上游服务器超时间，超过则选择另外一个服务器 proxy_connect_timeout 3s; # tcp连接闲置时间，超过则关闭 proxy_timeout 10s; proxy_pass web; } log_format proxy '$remote_addr $remote_port $protocol $status [$time_iso8601] ' '\"$upstream_addr\" \"$upstream_bytes_sent\" \"$upstream_connect_time\"' ; access_log /usr/local/nginx/logs/proxy.log proxy; } 配置后端测试页面 echo \"this is 128 page\" > /usr/local/nginx/html/index.html echo \"this is 135 page\" > /usr/local/nginx/html/index.html 访问前端服务器 # 在后端135上访问130： [root@node5 ~]# curl 192.168.75.130/index.html this is 128 page # 查看后端128日志： [root@node2 ~]# tailf /usr/local/nginx/logs/access.log 192.168.75.130 - - [2020-07-31T11:07:56+08:00] \"GET/index.html HTTP/1.1\" 200 17 \"-\" \"curl/7.29.0\" \"-\" # 查看前端130代理日志： [root@node3 nginx-1.16.0]# tailf /usr/local/nginx/logs/proxy.log 192.168.75.135 57704 TCP 200 [2020-07-31T11:07:56+08:00]\"192.168.75.128:80\" \"88\" \"0.001\" 端口转发 # 前端130上配置如下： stream { upstream web { server 192.168.75.128:22; } server { listen 2222; proxy_connect_timeout 3s; proxy_timeout 10s; proxy_pass web; #proxy_set_header X-Real-IP $remote_addr; } log_format proxy '$remote_addr $remote_port $protocol $status [$time_iso8601] ' '\"$upstream_addr\" \"$upstream_bytes_sent\" \"$upstream_connect_time\"' ; access_log /usr/local/nginx/logs/proxy.log proxy; } # 在另外一台服务器ssh连接： [root@node5 ~]# ssh 192.168.75.130 -p 2222 root@192.168.75.130s password: Last login: 01 08 2020 02:24:19 GMT from 192.168.75.130 [root@node2 ~]# [root@node2 ~]# # 可以看到，已经登录到了128服务器上。 [root@node2 ~]# ip a 1: lo: mtu 65536 qdisc noqueue state UNKNOWN qlen 1 link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00 inet 127.0.0.1/8 scope host lovalid_lft forever preferred_lft forever inet6 ::1/128 scope host valid_lft forever preferred_lft forever 2: ens32: mtu 1500 qdiscpfifo_fast state UP qlen 1000 link/ether 00:50:56:2a:4e:7f brd ff:ff:ff:ff:ff:ff inet 192.168.75.128/24 brd 192.168.75.255 scope global ens32 valid_lft forever preferred_lft forever inet6 fe80::52eb:5720:d625:841/64 scope link valid_lft forever preferred_lft forever By xiaobei，使用知识共享 署名-相同方式共享 4.0协议发布            此页面修订于： 2020-08-15 09:39:51 "},"book/technology/linux/Special-lecture/mysql入门安装.html":{"url":"book/technology/linux/Special-lecture/mysql入门安装.html","title":"mysql 入门安装","keywords":"","body":"Mysql 数据库简介 MySQL 是一种关系数据库管理系统，关系数据库将数据保存在不同的表中，而不是将所有数据放在一个大仓库内，这样就增加了速度并提高了灵 活性。MySQL 所使用的 SQL 语言是用于访问数据库的最常用标准化语言。 关系数据库管理系统(Relational Database Management System，RDBMS)，是将数据组织为相关的行和列的系统，而管理关系数据库的计算机软件就是关系数据库管理系统 。 数据库一般分为以下两种： 关系型数据库； 非关系型数据库。 常用的关系型数据库软件有: MYSQL、Mariadb、Oracle、SQL Server、PostgreSQL、DB2 等常用的非关系型数据库软件有: Redis、memcached。 MySQL 现阶段有免费版本和付费版本，公司里面使用 MySQL 多数都是使用免费版本。 Mariadb 数据库是 MySQL 数据库原来的团队，后续独立出来进行开发的完全开源版本。 mysql 引擎 MySQL 引擎有很多，企业里面主流的 myisam、innodb 两种 MyISAM：主要强调的是性能，其执行数度比 InnoDB 类型更快，但不提供事务支持，不支持外键，如果执行大量的 SELECT(查询)操作，MyISAM 是更好的选择，支持表锁。myisam 引擎查询性能高。 InnoDB：提供事务支持事务、外键、行级锁等高级数据库功能，可执行大量的 INSERT 或 UPDATE，InnoDB 引擎写性能高。 Mysql 数据库安装 MySQL 安装方式有两种，一种是 yum/rpm 安装，另外一种是 tar 源码安装。 yum 安装 Yum 安装方法很简单，执行命令如下即可: Centos6: yum install –y mysql-server mysql-devel mysql Centos7:yum install –y mariadb mariadb-devel mariadbserver # 安装完成之后可以查询一下软件是否安装成功： [root@localhost ~]# rpm -qa|grep mariadb mariadb-libs-5.5.60-1.el7_5.x86_64 mariadb-server-5.5.60-1.el7_5.x86_64 mariadb-5.5.60-1.el7_5.x86_64 mariadb-devel-5.5.60-1.el7_5.x86_64 Mariadb 和 mysql 数据库软件命令和配置都是类似的。 源码安装 5.5 版本 cd /usr/src wget http://mirrors.163.com/mysql/Downloads/MySQL5.5/mysql-5.5.60.tar.gz tar xf mysql-5.5.60.tar.gz cd mysql-5.5.60/ yum install gcc ncurses-devel libaio bison gcc-c++ git cmake ncurses-devel ncurses -y cmake . -DCMAKE_INSTALL_PREFIX=/usr/local/mysql55/ \\ -DMYSQL_UNIX_ADDR=/tmp/mysql.sock \\ -DMYSQL_DATADIR=/data/mysql \\ -DSYSCONFDIR=/usr/local/mysql55/ \\ -DMYSQL_USER=mysql \\ -DMYSQL_TCP_PORT=3306 \\ -DWITH_XTRADB_STORAGE_ENGINE=1 \\ -DWITH_INNOBASE_STORAGE_ENGINE=1 \\ -DWITH_PARTITION_STORAGE_ENGINE=1 \\ -DWITH_BLACKHOLE_STORAGE_ENGINE=1 \\ -DWITH_MYISAM_STORAGE_ENGINE=1 \\ -DWITH_READLINE=1 \\ -DENABLED_LOCAL_INFILE=1 \\ -DWITH_EXTRA_CHARSETS=1 \\ -DDEFAULT_CHARSET=utf8 \\ -DDEFAULT_COLLATION=utf8_general_ci \\ -DEXTRA_CHARSETS=all \\ -DWITH_BIG_TABLES=1 \\ -DWITH_DEBUG=0 make && make install cp support-files/my-large.cnf /usr/local/mysql55/my.cnf cp support-files/mysql.server /etc/init.d/mysqld chmod +x /etc/init.d/mysqld mkdir -p /data/mysql useradd -s /sbin/nologin mysql chown -R mysql. /data/mysql /usr/local/mysql55/scripts/mysql_install_db --user=mysql --datadir=/data/mysql --basedir=/usr/local/mysql55 /etc/init.d/mysqld start 加入service服务： chkconfig --add mysqld chkconfig --level 35 mysqld on service mysqld restart 常见报错 客户端连接报错 ERROR 2002 (HY000): Cant connect to local MySQL server through socket '/var/lib/mysql/mysql.sock' (2) # 分析原因： 找不到套接字，怎么找？ [root@node3 ~]# ps -ef |grep mysqld root 5165 1 0 21:22 pts/0 00:00:00 /bin/sh /usr/local/mysql55/bin/mysqld_safe --datadir=/data/mysql --pid-file=/data/mysql/node3.pid mysql 5536 5165 0 21:22 pts/0 00:00:01 /usr/local/mysql55/bin/mysqld --basedir=/usr/local/mysql55 --datadir=/data/mysql --plugindir=/usr/local/mysql55/lib/plugin --user=mysql --logerror=/var/log/mariadb/mariadb.log --pidfile=/data/mysql/node3.pid --socket=/tmp/mysql.sock --port=3306 #解决方案一： [root@node3 ~]# mysql -S /tmp/mysql.sock #解决方案二： [root@node3 ~]# ln -s /tmp/mysql.sock /var/lib/mysql/mysql.sock 源码安装 5.7 版本 # 安装依赖： yum install gcc ncurses-devel libaio bison gcc-c++ git cmake ncurses-devel openssl openssl-devel -y ​ wget http://nchc.dl.sourceforge.net/project/boost/boost/1.59.0/boost_1_59_0.tar.gz tar xf boost_1_59_0.tar.gz mv boost_1_59_0 /usr/local/boost # Boost库是为C++语言标准库提供扩展的一些C++程序库的总称，由Boost社区组织开发、维护 ​ wget http://mirrors.163.com/mysql/Downloads/MySQL-5.7/mysql-5.7.28.tar.gz tar xf mysql-5.7.28.tar.gz cd mysql-5.7.28 ​ cmake . -DCMAKE_INSTALL_PREFIX=/usr/local/mysql57 \\ -DMYSQL_UNIX_ADDR=/data/mysql57/mysql.sock \\ -DMYSQL_DATADIR=/data/mysql57 \\ -DSYSCONFDIR=/usr/local/mysql57 \\ -DMYSQL_USER=mysql \\ -DMYSQL_TCP_PORT=3307 \\ -DWITH_XTRADB_STORAGE_ENGINE=1 \\ -DWITH_INNOBASE_STORAGE_ENGINE=1 \\ -DWITH_PARTITION_STORAGE_ENGINE=1 \\ -DWITH_BLACKHOLE_STORAGE_ENGINE=1 \\ -DWITH_MYISAM_STORAGE_ENGINE=1 \\ -DWITH_READLINE=1 \\ -DENABLED_LOCAL_INFILE=1 \\ -DWITH_EXTRA_CHARSETS=1 \\ -DDEFAULT_CHARSET=utf8 \\ -DDEFAULT_COLLATION=utf8_general_ci \\ -DEXTRA_CHARSETS=all \\ -DWITH_BIG_TABLES=1 \\ -DWITH_DEBUG=0 \\ -DENABLE_DTRACE=0 \\ -DDOWNLOAD_BOOST=1 \\ -DWITH_BOOST=/usr/local/boost ​ make && make install ​ mkdir -p /data/mysql57 useradd -s /sbin/nologin mysql chown -R mysql. /data/mysql57 ​ cp support-files/mysql.server /etc/init.d/mysqld57 chmod +x /etc/init.d/mysqld57 ​ vim /usr/local/mysql57/my.cnf [mysqld] basedir=/usr/local/mysql57/ datadir=/data/mysql57/ port=3307 pid-file=/data/mysql57/mysql.pid socket=/data/mysql57/mysql.sock ​ [mysqld_safe] log-error=/data/mysql57/mysql.log ​ #初始化 /usr/local/mysql57/bin/mysqld --initialize --user=mysql --datadir=/data/mysql57 \\ --basedir=/usr/local/mysql57/ ​ /etc/init.d/mysqld57 start ​ ## 登录后修改密码： > alter user user() identified by \"123\"; ​ ### 或者跳过权限修改： 跳过权限： vim /usr/local/mysql57/my.cnf 在[mysqld]字段下添加： skip-grant-tables ​ 然后重启服务： /etc/init.d/mysqld restart ​ 免密进入数据库： 如果只启动了一个数据库服务，可以直接用下面的命令进入，要是有多个服务启动，会默认进入3306的数据库，到时可以指定IP和端口进入。 /usr/local/mysql57/bin/mysql 更新密码为空： update mysql.user set authentication_string=password('') where user=\"root\"; ​ # MySQL5.7默认监听ipv6地址，用ipv4地址也是可以正常访问，如果想改为ipv4，可以在[mysqld]字段下配置一下参数，然后重启服务： bind-address=0.0.0.0 mysql 安装目录介绍 # 源码安装mysql 版本: ​ mysql 主配置目录:/usr/local/mysql55 mysql 数据目录：/data/mysql mysql 命令目录：/usr/local/mysql55/bin/* 比如：mysql、mysqld等。 mysql 配置文件：/usr/local/mysql55/my.cnf mysql 启动文件：/usr/local/mysql55/support-files/mysql.server 或者 是/etc/init.d/mysqld mysql 日志文件：/data/mysql ​ ​ ​ # yum 安装mariadb程序： ​ mariadb 主配置目录:/var/lib/mysql mariadb 数据目录：/var/lib/mysql mariadb 命令目录：/usr/bin mariadb 默认配置文件：/etc/my.cnf mariadb 启动文件：/usr/bin mariadb 日志文件：/var/log/mariadb By xiaobei，使用知识共享 署名-相同方式共享 4.0协议发布            此页面修订于： 2020-08-15 09:39:51 "},"book/technology/linux/Special-lecture/mysql数据库基础操作.html":{"url":"book/technology/linux/Special-lecture/mysql数据库基础操作.html","title":"mysql 数据库基础操作","keywords":"","body":"登录数据库服务器 # 通过unix套接字连接 直接通过mysql 或者mysql -uroot -p 登录 ​ # 查看连接状态： status ​ MariaDB [(none)]> status; -------------- mysql Ver 15.1 Distrib 5.5.64-MariaDB, for Linux (x86_64) using readline 5.1 ​ # 当前使用的那个数据库，没有选择为空： Current database: # 是否使用加密 SSL: Not in use Current pager: stdout Using outfile: '' # 结束符为分号 Using delimiter: ; Server: MariaDB Server version: 5.5.64-MariaDB MariaDB Server Protocol version: 10 # 连接方式，本地套接字 Connection: Localhost via UNIX socket Server characterset: latin1 Db characterset: latin1 Client characterset: utf8 Conn. characterset: utf8 # 套接字地址 UNIX socket: /var/lib/mysql/mysql.sock Uptime: 7 min 21 sec # 通过tcp套接字连接 通过mysql -h127.0.0.1 登录服务器，查看状态： ​ 可以看到连接id不同，套接字也不同，使用的是tcp/ip的套接字通信。 如果有时候遇到无法通过本地套接字连接，可以使用指定服务器ip连接。 常用命令操作 数据库的操作命令 # 查询数据库： show databases: # 初始化后，默认会有四个数据库： information_schema：信息数据库。主要保存着关于MySQL服务器所维护的所有其他数据库的信息，如数据库名，数据库的表，表栏的数据类型与访问权 限等。通过show databases;查看到数据库信息，也是出自该数据库中得SCHEMATA表。 mysql： mysql的核心数据库。主要负责存储数据库的用户、权限设置、关键字等mysql自己需要使用的控制和管理信息。 performance_schema： 用于性能优化的数据库。 # 查看数据库的创建语句： show create database mysql; mysql为数据库名。 ​ # 查看字符集命令： show character set; ​ # 修改数据库的字符集： alter database zabbix default character set utf8; ​ # 创建数据库： create database zabbix charset=utf8; 或者： create database if not exists zabbix charset=gbk; 用上面的这条命令创建数据库，如果数据库已经存在就不会报错了。 ​ # 查看警告： show warnings; ​ # 删除数据库： drop database zabbix; ​ 或者： drop database if exists zabbix; 用上面这种方式删除数据库，如果数据库不存在就不会报错了。 创建表命令 create table t1( id int(10) auto_increment primary key, name varchar(20), job varchar(10) ); 查看表结构相关命令 #查看所有表： use mysql; show tables; #或者 show tables from mysql; ​ #查看所有表的详细信息： use mysql; show table status\\G #或者 show table status from mysql\\G ​ #查看某张表的详细信息： use mysql; show table status like \"user\"\\G #或者 show table status from mysql like \"user\"\\G ​ #查看表结构： desc mysql.user; ​ #查看创建表的sql语句： show create table mysql.user\\G 修改表结构相关命令 #添加表字段： alter table t1 add job varchar(20); ​ #默认是加在后面，如果想加在第一列，或者某个字段后可以进行指定： #加在第一列 alter table t1 add job2 varchar(20) first; #加在name字段后： alter table t1 add job3 varchar(20) after name; ​ #修改表字段名，需要将字段属性写全： alter table t1 change id age int(5); id: 原字段 age: 新字段 ​ #修改表字段的属性或者位置： #修改字段的顺序，把job3放在第一列： alter table t1 modify job3 varchar(20) first; ​ #删除表字段： alter table t1 drop brith1; 增 # 全字段增加数据： insert into t1 values(1,\"xiaoming\",\"it\"); #或者 insert t1(name) values(2，\"xiaohua\"); #或者 insert t1 set name=\"xiaoming\", job=\"teacher\"; ​ # 指定字段增加数据： insert into t1(name) value(\"xiaoqiang\"),(\"xiaowang\"); 删 #物理删除，数据就真没有了 delete from t1 where id=2; ​ #逻辑删除，需要添加一个字段，默认设置为0： alter table t1 add isdelete bit default 0; ​ #将isdelete字段设置为1： update t1 set isdelete=1 where id=3; ​ #然后查找isdelete字段为0得数据即可过滤了： select * from t1 where isdelete=0; 改 #修改表中得数据，不增加行,insert into会增加行： update t1 set name=\"xiaoxiao\" where id=6; t1是表名， name是字段名， where后面是条件语句，如果没有，就是对整个表得修改了，要慎重！ ​ #修改多个字段用逗号分隔： update t1 set name=\"xiaoqiang\",job=\"engineer\" where id=3; 查 #全字段查找，不建议： select * from t2; ​ #查找指定字段： select name,job from t2; 运算符 根据运算符查找 > 大于 >= 大于等于 = 等于 = 4; ​ and 多个条件同时满足 or 几个条件，满足其一即可 ​ 查找id大于等于3，并且没有标记删除的数据 select id,name,job,isdelete from t2 where id >= 3 and isdelete=0; 模糊查找 like 模糊查找 % 匹配任意多个字符 _ 匹配单个字符 ​ 查找名字中含有xiao字符的数据： select id,name,job from t2 where name like \"xiao%\"; ​ 插入一条数据，查找名字中含有xiao并且后面跟一个单字符的数据 insert t2(name) value(\"xiaom\"); select id,name,job from t2 where name like \"xiao_\"; 范围查找 in 表示非连续的范围 between A and B 表示一个连续的范围内 not 不在某个条件内 ​ 查找id等于2，4或者6的数据 select id,name,job from t2 where id in (2,4,6); ​ 查找id在3到6之间数据（包含3和6）： select id,name,job from t2 where id between 3 and 6; ​ 查找id不等于3，6的数据： select id,name,job from t2 where id not in (3,6); 查找空值 is null 查找空值 ​ select id,name,job from t2 where job is null; 聚合 select max(age) from t2; select min(age) from t2; select count(*) from t2 where isdelete=0; 排序 order by 字段 asc 根据“列”从小到大排序 order by 字段 desc 根据“列”从大到小排序 ​ 根据id，从大到小进行排序： select * from t2 order by id desc; 分组 group by 字段 ​ #根据名字分组，统计同名的个数： select count(*),name from t2 group by name; 限制 limit n; 显示前n行 ​ #显示前三行 select * from t2 limit 3; #显示从第3行开始后的3行； select * from t2 limit 3,3; #显示从第3行开始后的4行 select * from t2 limit 4 offset 3; 视图的相关操作 视图并不是真实存在的表，主要是将常用的到字段或者数据整合成一个“表”。 创建视图 # 先创建表： create table t1 ( id int(10) not null auto_increment primary key, name varchar(20), job varchar(10) ); # 插入数据： insert t1 set name=\"xiaoming\", job=\"it\"; insert t1 set name=\"xiaowang\", job=\"it\"; insert t1 set name=\"xiaohong\", job=\"it\"; # 创建视图： create view v1 as select name,job from t1; create view v2 as select * from t1 where id >= 2; 查看视图 # 查看所有视图： select * from information_schema.views where table_schema=\"test\"\\G # 查看某个视图结构： desc v2; # 查看视图内容： select * from v2; 删除视图 drop view v2; 或者 drop view if exists v2; 修改视图 alter view v1 as select id,job from t1; 修改密码 密码为空或者已知当前密码 #方法一：用SET PASSWORD命令 #首先登录MySQL。 #格式：mysql> set password for 用户名@localhost = password('新密码'); #范例： mysql> set password for root@localhost = password('123'); #方法二：在shell终端执行： ​ mysql -uroot -p -e \"set password for root@localhost=password('123');\" ​ #ps:注意双引号和单引号！！！ #方法三：在shell终端用mysqladmin ​ #格式：mysqladmin -u用户名 -p旧密码 password 新密码 ​ #范例： mysqladmin -uroot -p123456 password 123 #方法四：用UPDATE直接编辑user表 #首先登录MySQL。 mysql> use mysql; mysql> update user set password=password('123') where user='root' and host='localhost'; mysql> flush privileges; 忘记密码 # yum安装的mysql ​ #可执行使用/usr/bin/mysqld_safe --user=mysql --skip-grant-tables & ​ #然后用mysql命令进入修改密码： update mysql.user set password=password('') where user=\"root\" and host=\"localhost\"; flush privileges; By xiaobei，使用知识共享 署名-相同方式共享 4.0协议发布            此页面修订于： 2020-08-15 09:39:51 "},"book/technology/linux/Special-lecture/mysql主从同步及mysqldump备份.html":{"url":"book/technology/linux/Special-lecture/mysql主从同步及mysqldump备份.html","title":"mysql 主从同步及 mysqldump 备份","keywords":"","body":"Mysql 主从概念 mysql 的主从复制，是用来建立一个和主数据库完全一样的数据库环境，从库会同步主库得所有数据，可轻松实现故障转移。 mysql 主从主要作用 实现数据备份； 基于数据备份，实现故障转移； 基于数据备份，实现读写分离； 常见 mysql 主从架构 MySQL 主从部署 master: 192.168.75.130 slave: 192.168.75.135 主从工作原理 master 端配置 # 安装好mysql/mariadb数据库： yum install mariadb mariadb-server -y # 修改配置文件，在[mysqld]指令段添加以下行：(/etc/my.cnf) log-bin=xiaobei-bin server-id=1 ​ # 启动数据库服务： [root@localhost ~]# systemctl start mariadb [root@localhost ~]# # 查看mysql进程： [root@localhost ~]# ps -ef |grep mysqld mysql 2040 1 0 01:15 ? 00:00:00 /bin/sh /usr/bin/mysqld_safe --basedir=/usr mysql 2203 2040 0 01:15 ? 00:00:02 /usr/libexec/mysqld --basedir=/usr --datadir=/data/mysql --plugin-dir=/usr/lib64/mysql/plugin --log-error=/var/log/mariadb/mariadb.log --pid-file=/var/run/mariadb/mariadb.pid --socket=/var/lib/mysql/mysql.sock root 2316 1946 0 02:05 pts/0 00:00:00 grep --color=auto mysqld # 查看mysql端口： [root@localhost ~]# netstat -ntlp |grep 3306 tcp 0 0 0.0.0.0:3306 0.0.0.0:* LISTEN 2203/mysqld 查看配置是否生效 # 通过mysql直接进入数据库： [root@localhost ~]# mysql Welcome to the MariaDB monitor. Commands end with ; or \\g. Your MariaDB connection id is 3 Server version: 5.5.65-MariaDB MariaDB Server ​ Copyright (c) 2000, 2018, Oracle, MariaDB Corporation Ab and others. ​ Type 'help;' or '\\h' for help. Type '\\c' to clear the current input statement. ​ MariaDB [(none)]> # 查看log_bin和sql_log_bin是否均为on; MariaDB [(none)]> show variables like \"%log_bin\"; +---------------+-------+ | Variable_name | Value | +---------------+-------+ | log_bin | ON | | sql_log_bin | ON | +---------------+-------+ 2 rows in set (0.00 sec) 授权从库 MariaDB [(none)]> grant replication slave on *.* to \"tongbu\"@\"192.168.75.135\" identified by \"123456\"; MariaDB [(none)]> flush privileges; Query OK, 0 rows affected (0.00 sec) 查看 master 状态 MariaDB [(none)]> show master status; +--------------------+----------+--------------+------------------+ | File | Position | Binlog_Do_DB | Binlog_Ignore_DB | +--------------------+----------+--------------+------------------+ | xiaobei-bin.000002 | 476 | | | +------------------+------------+--------------+------------------+ 1 row in set (0.00 sec) slave 端配置 # 修改配置文件，在[mysqld]指令块下添加如下行：(/etc/my.cnf) server-id=2 启动数据库服务 [root@localhost ~]# systemctl start mariadb 指定 master MariaDB [(none)]> change master to -> master_host=\"192.168.75.130\", -> master_user=\"tongbu\", -> master_password=\"123456\", -> master_log_file=\"xiaobei-bin.000002\", -> master_log_pos=476; 查看 slave 状态 MariaDB [(none)]> slave start; Query OK, 0 rows affected (0.00 sec) ​ MariaDB [(none)]> show slave status\\G *************************** 1. row *************************** Slave_IO_State: Waiting for master to send event Master_Host: 192.168.75.130 Master_User: tongbu Master_Port: 3306 Connect_Retry: 60 Master_Log_File: tongbu-bin.000002 Read_Master_Log_Pos: 476 Relay_Log_File: mariadb-relay-bin.000002 Relay_Log_Pos: 529 Relay_Master_Log_File: tongbu-bin.000002 Slave_IO_Running: Yes Slave_SQL_Running: Yes Replicate_Do_DB: Replicate_Ignore_DB: Replicate_Do_Table: Replicate_Ignore_Table: Replicate_Wild_Do_Table: Replicate_Wild_Ignore_Table: Last_Errno: 0 Last_Error: Skip_Counter: 0 Exec_Master_Log_Pos: 476 Relay_Log_Space: 825 Until_Condition: None Until_Log_File: Until_Log_Pos: 0 Master_SSL_Allowed: No Master_SSL_CA_File: Master_SSL_CA_Path: Master_SSL_Cert: Master_SSL_Cipher: Master_SSL_Key: Seconds_Behind_Master: 0 Master_SSL_Verify_Server_Cert: No Last_IO_Errno: 0 Last_IO_Error: Last_SQL_Errno: 0 Last_SQL_Error: Replicate_Ignore_Server_Ids: Master_Server_Id: 1 1 row in set (0.00 sec) 验证数据同步 # 在主库创建一个数据库： MariaDB [(none)]> create database xiaobei charset=utf8; Query OK, 1 row affected (0.00 sec) ​ MariaDB [(none)]> show databases; +--------------------+ | Database | +--------------------+ | information_schema | | xiaobei | | mysql | | performance_schema | | test | +--------------------+ ​ # 在从库查看： MariaDB [(none)]> show databases; +--------------------+ | Database | +--------------------+ | information_schema | | xiaobei | | mysql | | performance_schema | | test | +--------------------+ 5 rows in set (0.00 sec) 同步错误分析 Slave_IO_Running: Connecting # 第一种：主库宕机 # 第二种：从库指定的用户名与密码错误（与主库授权的用户名和密码不一致） # 第三种：关闭防火墙 Slave_IO_Running: No # 从库指定的二进制文件有误 Slave_SQL_Running: No # pos点问题 主从复制延迟问题及解决方法 从库过多 建议从库数量 3-5 为宜，要复制的从节点数量过多，会导致复制延迟。 从库硬件差 从库硬件比主库差，导致复制延迟，查看 master 和 slave 的系统配置，可能会因为机器配置的问题，包括磁盘 IO、CPU、内存等各方面因素造成复制的延迟，一般发生在高并发大数据量写入场景。 网络问题 主从库之间的网络延迟，主库的网卡、网线、连接的交换机等网络设备都可能成为复制的瓶颈，导致复制延迟。 Mysqldump 备份 只备份表，不备份数据本身 # 备份zabbix数据库中的所有表，但是不会自动生成创建zabbix数据库的语句： mysqldump -uroot -p*** zabbix > zabbix.sql 备份数据库与表 # 备份zabbix数据库中的所有表，并且会生成创建zabbix数据库的SQL语句，也就是导入时不需要先创建数据库： mysqldump -uroot -p*** --databases zabbix > zabbix.sql 备份多个数据库 mysqldump -uroot -p*** --databases zabbix mysql > zabbix_mysql.sql 备份所有数据库 mysqldump -uroot -p*** --all-databases > all.sql # 或者 mysqldump -uroot -p*** -A > all.sql 备份 zabbix 数据库，并且记录 pos 点 mysqldump -uroot -p --master-data zabbix > zabbix.sql 备份数据库，并刷新日志 mysqldump -uroot -p --master-data --flush-logs zabbix > zabbix.sql By xiaobei，使用知识共享 署名-相同方式共享 4.0协议发布            此页面修订于： 2020-08-15 09:39:51 "},"book/technology/linux/Special-lecture/mysql读写分离实战.html":{"url":"book/technology/linux/Special-lecture/mysql读写分离实战.html","title":"mysql 读写分离实战","keywords":"","body":"MySQL 读写分离概念 MYSQL 读写分离的原理其实就是让 Master 数据库处理事务性增、删除、修改、更新操作（CREATE、INSERT、UPDATE、DELETE），而让 Slave 数据库处理 SELECT 操作，MYSQL 读写分离前提是基于 MYSQL 主从复制，这样可以保证在 Master 上修改数据，Slave 同步之后，WEB 应用可以读取到 Slave 端的数据。 读写分离实现方式 实现 MYSQL 读写分离可以基于第三方插件，也可以通过开发修改代码实现，具体实现的读写分离的常见方式有如下四种： Amoeba 读写分离； MySQL-Proxy 读写分离； Mycat 读写分离； 基于程序读写分离(效率很高，实施难度大，开发改代码)； Amoeba是阿里 08 年开源的以 MySQL 为底层数据存储，并对 WEB、APP 应用提供 MySQL 协议接口的 proxy。它集中地响应 WEB 应用的请求，依据用户事先设置的规则，将 SQL 请求发送到特定的数据库上执行，基于此可以实现负载均衡、读写分离、高可用性等需求。 Mysql-Proxy是 MySQL 官方提供的 mysql 中间件服务，支持无数客户端连接，同时后端可连接若干台 Mysql-Server 服务器，MYSQL-Proxy 自身基于 MySQL 协议，连接 MYSQL-Proxy 的客户端无需修改任何设置， 跟正常连接 MYSQL Server 没有区别，无需修改程序代码。 Mycat是基于阿里 12 年开源的 cobar 开发的一个数据库中间件，在架构体系中是位于数据库和应用层之间的一个组件，并且对于应用层是透明的，它可实现读写分离，分库分表。 基于 mysql-proxy 实现读写分离 proxy: 192.168.75.133 master: 192.168.75.134 slave: 192.168.75.135 工作原理图解 配置 proxy proxy 可以选择和 mysql 部署在同一台服务器，也可以选择单独部署在另一台独立服务器。 # 下载mysql-proxy： wget http://mirrors.163.com/mysql/Downloads/MySQL-Proxy/mysql-proxy-0.8.4-linux-el6-x86-64bit.tar.gz # 解压： tar xf mysql-proxy-0.8.4-linux-el6-x86-64bit.tar.gz mv mysql-proxy-0.8.4-linux-el6-x86-64bit /usr/local/mysql-proxy # 配置环境变量： [root@node3 src]# echo \"export PATH=/usr/local/mysql-proxy/bin:$PATH\" > /etc/profile.d/mysql-proxy.sh [root@node3 src]# . /etc/profile.d/mysql-proxy.sh # 启动MYSQL-Proxy中间件: [root@node3 src]# useradd -r mysql-proxy [root@node3 src]# mysql-proxy --daemon --log-level=debug --user=mysql-proxy --keepalive --log-file=/var/log/mysql-proxy.log --plugins=\"proxy\" --proxy-backend-addresses=\"192.168.75.134:3306\" --proxy-read-only-backend-addresses=\"192.168.75.135:3306\" --proxy-lua-script=\"/usr/local/mysql-proxy/share/doc/mysql-proxy/rw-splitting.lua\" --plugins=admin --admin-username=\"admin\" --admin-password=\"admin\" --admin-lua-script=\"/usr/local/mysql-proxy/lib/mysql-proxy/lua/admin.lua\" ​ # 查看端口/日志： [root@node3 src]# netstat -ntlp |grep 40 tcp 0 0 0.0.0.0:4040 0.0.0.0:* LISTEN 1348/mysql-proxy tcp 0 0 0.0.0.0:4041 0.0.0.0:* LISTEN 1348/mysql-proxy 启动的相关参数 # Mysql-Proxy的相关参数详解如下： --help-all ：获取全部帮助信息； --proxy-address=host:port ：代理服务监听的地址和端口，默认为4040； --admin-address=host:port ：管理模块监听的地址和端口，默认为4041； --proxy-backend-addresses=host:port ：后端mysql服务器的地址和端口； --proxy-read-only-backend-addresses=host:port ：后端只读mysql服务器的地址和端口； --proxy-lua-script=file_name ：完成mysql代理功能的Lua脚本； --daemon ：以守护进程模式启动mysql-proxy； --keepalive ：在mysql-proxy崩溃时尝试重启之； --log-file=/path/to/log_file_name ：日志文件名称； --log-level=level ：日志级别； --log-use-syslog ：基于syslog记录日志； --plugins=plugin ：在mysql-proxy启动时加载的插件； --user=user_name ：运行mysql-proxy进程的用户； --defaults-file=/path/to/conf_file_name ：默认使用的配置文件路径，其配置段使用[mysql-proxy]标识； --proxy-skip-profiling ：禁用profile； --pid-file=/path/to/pid_file_name ：进程文件名； 启动 master/slave systemctl start mariadb 查看读写分离状态 基于 4041 端口 MySQL-Proxy 查看读写分离状态，登录 4041 管理端口 ： mysql -h192.168.75.133 -uadmin -padmin -P4041 ​ # 这时可以看到后端数据库信息，只是状态为unknown,表示还没有客户端连接，可以通过4040代理端口通过 查询数据等操作激活。 mysql> select * from backends; +-------------+---------------------+---------+------+------+-------------------+ | backend_ndx | address | state | type | uuid | connected_clients | +-------------+---------------------+---------+------+------+-------------------+ | 1 | 192.168.75.134:3306 | unknown | rw | NULL | 0 | | 2 | 192.168.75.135:3306 | unknown | ro | NULL | 0 | +-------------+---------------------+---------+------+------+-------------------+ 2 rows in set (0.00 sec) 授权 proxy grant all on *.* to \"mysql-proxy\"@\"192.168.75.133\" identified by \"123456\"; 通过代理创建数据 通过4040 代理端口插入数据，该 sql 语句会走 master，于是可以激活 master 状态： mysql -h192.168.75.133 -umysql-proxy -p123456 -P4040 -e \"create database xiaobei charset utf8;\" 在4041 管理端口，再次查看： mysql> select * from backends; +-------------+---------------------+---------+------+------+-------------------+ | backend_ndx | address | state | type | uuid | connected_clients | +-------------+---------------------+---------+------+------+-------------------+ | 1 | 192.168.75.134:3306 | up | rw | NULL | 0 | | 2 | 192.168.75.135:3306 | unknown | ro | NULL | 0 | +-------------+---------------------+---------+------+------+-------------------+ 2 rows in set (0.00 sec) 通过代理查询数据 # 先在从库选择xiaobei数据库（因为主从关系，在主库创建的xiaobei会同步至从库），创建表格，并插入数据： MariaDB [(none)]> use xiaobei Database changed MariaDB [xiaobei]> create table t1( id int, name varchar(20) ); Query OK, 0 rows affected (0.00 sec) ​ MariaDB [xiaobei]> insert t1 values(1,\"xiaoming\"); Query OK, 1 row affected (0.00 sec) 通过4040 代理端口查询数据，该 sql 语句会走 slave，于是可以激活 slave 状态： # 多执行几次！ [root@node4 ~]# mysql -h192.168.75.133 -umysql-proxy -p123456 -P4040 -e \"select * from xiaobei.t1;\" +------+----------+ | id | name | +------+----------+ | 1 | xiaoming | +------+----------+ 在4041 管理端口，再次查看 mysql> select * from backends; +-------------+---------------------+-------+------+------+-------------------+ | backend_ndx | address | state | type | uuid | connected_clients | +-------------+---------------------+-------+------+------+-------------------+ | 1 | 192.168.75.134:3306 | up | rw | NULL | 0 | | 2 | 192.168.75.135:3306 | up | ro | NULL | 0 | +-------------+---------------------+-------+------+------+-------------------+ 2 rows in set (0.00 sec) 基于 Mycat 实现读写分离 Mycat 基于阿里开源的 Cobar 产品而研发 , 一个彻底开源的，面向企业应用开发的大数据库集群 , 一个可以视为 MySQL 集群的企业级数据库，用来替代昂贵的 Oracle 集群 ，MYCAT 并不依托于任何一个商业公司， 永不收费，永不闭源 ！ mycat: 192.168.75.133 master: 192.168.75.134 slave: 192.168.75.135 安装 mycat # 下载mycat: wget http://dl.mycat.io/1.6.7.1/Mycat-server-1.6.7.1-release-20190627191042-linux.tar.gz # 解压： tar xf Mycat-server-1.6.7.1-release-20190627191042-linux.tar.gz -C /usr/local/ # 安装java-jdk： yum install java-1.8.0-openjdk -y # 配置mycat环境变量： echo \"export PATH=/usr/local/mycat/bin:$PATH\" > /etc/profile.d/mycat.sh . /etc/profile.d/mycat.sh 授权 mycat # 在主库执行授权信息，从库会自动同步： grant all on *.* to \"mycat-proxy\"@\"192.168.75.133\" identified by \"123456\"; 配置 mycat # 配置server.xml ​ # 默认管理用户，可读可写： 123456 xiaobeidb ... # 只读用户： user xiaobeidb true ​ # 配置schema.xml ​ # 设置逻辑库以及数据库节点 # 配置数据库节点对应的后端真实的数据库： # 配置读写库以及均衡： select user() 启动 mycat mycat start 连接测试 mysql -umycat -p123456 -P8066 -h127.0.0.1 MySQL [(none)]> show databases; +-----------+ | DATABASE | +-----------+ | xiaobeidb | +-----------+ 1 row in set (0.00 sec) ​ # 可以在后端主库创建一个表，继续查询表测试： MySQL [(none)]> use xiaobeidb; Reading table information for completion of table and column names You can turn off this feature to get a quicker startup with -A ​ Database changed MySQL [xiaobeidb]> show tables; +--------------------+ | Tables_in_students | +--------------------+ | t1 | +--------------------+ 1 row in set (0.01 sec) ​ # 在从库插入数据，继续查询： MySQL [xiaobeidb]> select * from t1; +------+----------+ | id | name | +------+----------+ | 1 | xiaowang | +------+----------+ 1 rows in set (0.00 sec) 在主库查不到数据，通过代理可以查到，即可验证读写分离成功。 报错解决 MySQL [xiaobeidb]> show tables; ERROR 1184 (HY000): Invalid DataSource:0 ​ # 可能是后端节点出现了问题，也有可能是代理端无法连上后端节点导致： # 可以先在代理端直接用授权用户名和密码登录后端数据库测试连接问题： [root@node3 conf]# mysql -umycat-proxy -h192.168.75.134 -p123456 ERROR 1129 (HY000): Host 'node3' is blocked because of many connection errors; unblock with 'mysqladmin flush-hosts' # 可以看到因为多次错误，代理端服务器被锁定了，所以也会出现上面的报错： # 在后端主库执行如下命令： mysqladmin flush-hosts # 再次测试，一般问题就能解决。 By xiaobei，使用知识共享 署名-相同方式共享 4.0协议发布            此页面修订于： 2020-08-15 09:39:51 "},"book/technology/linux/Special-lecture/LNMP高性能服务器.html":{"url":"book/technology/linux/Special-lecture/LNMP高性能服务器.html","title":"LNMP 高性能服务器","keywords":"","body":"企业实战 LNMP 高性能服务器 LNMP WEB 架构中，Nginx 为一款高性能 Web 服务器，本身是不能处理 PHP 的，当接收到客户端浏览器发送 HTTP Request 请求时,Nginx 服务器响应并处理 web 请求，静态资源 CSS、图片、视频、TXT 等静态文件请求，Nginx 服务器可以直接处理并回应。 但是 PHP 动态页面请求 Nginx 不能直接处理，Nginx 服务器会将 PHP 网页脚本通过接口传输协议（网关协议）PHP-FCGI（Fast-CGI）传输给 PHP-FPM（进程管理程序）,PHP-FPM 不做处理，然后 PHP-FPM 调用 PHP 解析器进程，PHP 解析器解析 PHP 脚本信息。PHP 解析器进程可以启动多个，可以实现多进行并发执行。 PHP 解释器将解析后的脚本返回到 PHP-FPM，PHP-FPM 再通过 Fast-CGI 的形式将脚本信息传送给 Nginx,Nginx 服务器再通过 Http Response 的形式传送给浏览器,浏览器再进行解析与渲染然后进行呈现。 1. 安装 mysql 1.1 预编译 cd /usr/src wget http://mirrors.163.com/mysql/Downloads/MySQL-5.5/mysql-5.5.60.tar.gz tar xf mysql-5.5.60.tar.gz cd mysql-5.5.60/ yum install gcc ncurses-devel libaio bison gcc-c++ git cmake ncurses-devel ncurses -y cmake . -DCMAKE_INSTALL_PREFIX=/usr/local/mysql55/ \\ -DMYSQL_UNIX_ADDR=/tmp/mysql.sock \\ -DMYSQL_DATADIR=/data/mysql \\ -DSYSCONFDIR=/usr/local/mysql55/ \\ -DMYSQL_USER=mysql \\ -DMYSQL_TCP_PORT=3306 \\ -DWITH_XTRADB_STORAGE_ENGINE=1 \\ -DWITH_INNOBASE_STORAGE_ENGINE=1 \\ -DWITH_PARTITION_STORAGE_ENGINE=1 \\ -DWITH_BLACKHOLE_STORAGE_ENGINE=1 \\ -DWITH_MYISAM_STORAGE_ENGINE=1 \\ -DWITH_READLINE=1 \\ -DENABLED_LOCAL_INFILE=1 \\ -DWITH_EXTRA_CHARSETS=1 \\ -DDEFAULT_CHARSET=utf8 \\ -DDEFAULT_COLLATION=utf8_general_ci \\ -DEXTRA_CHARSETS=all \\ -DWITH_BIG_TABLES=1 \\ -DWITH_DEBUG=0 1.2 编译/安装 make && make install cp support-files/my-large.cnf /usr/local/mysql55/my.cnf cp support-files/mysql.server /etc/init.d/mysqld chmod +x /etc/init.d/mysqld mkdir -p /data/mysql useradd -s /sbin/nologin mysql chown -R mysql. /data/mysql /usr/local/mysql55/scripts/mysql_install_db --user=mysql --datadir=/data/mysql --basedir=/usr/local/mysql55 /etc/init.d/mysqld start 1.3 添加系统服务 # 加入service服务： chkconfig --add mysqld chkconfig --level 35 mysqld on 2. 安装 nginx # 安装编译环境 yum install gcc gcc-c++ pcre pcre-devel zlib zlib-devel openssl openssl-devel -y # 下载源码： wget http://nginx.org/download/nginx-1.16.0.tar.gz # 解压： tar xf nginx-1.16.0.tar.gz cd nginx-1.16.0/ # 预编译： ./configure --prefix=/usr/local/nginx --with-http_stub_status_module # 编译/安装 make && make install # 修改nginx进程用户为nginx后查看 grep \"^user\" /usr/local/nginx/conf/nginx.conf user nginx; # 启动nginx: /usr/local/nginx/sbin/nginx 3. 安装 php # 安装依赖： yum -y install gd curl curl-devel libjpeg libjpeg-devel libpng libpng-devel freetype freetype-devel libxml2 libxml2-devel # 解压包： tar xf php-5.6.8.tar.bz2 cd php-5.6.8 # 预编译 ./configure --prefix=/usr/local/php \\ --enable-fpm \\ --enable-debug \\ --with-gd \\ --with-jpeg-dir \\ --with-png-dir \\ --with-freetype-dir \\ --enable-mbstring \\ --with-curl \\ --with-mysql=mysqlnd \\ --with-mysqli=mysqlnd \\ --with-pdo-mysql=mysqlnd \\ --with-config-file-path=/usr/local/php/etc \\ --with-zlib-dir # 编译/安装 make && make install cp php.ini-development /usr/local/php/etc/php.ini cp /usr/local/php/etc/php-fpm.conf.default /usr/local/php/etc/php-fpm.conf cp sapi/fpm/init.d.php-fpm /etc/init.d/php-fpm chmod +x /etc/init.d/php-fpm # 修改php-fpm的用户为nginx: [root@node4 html]# egrep \"^(user|group)\" /usr/local/php/etc/php-fpm.conf user = nginx group = nginx # 启动php-fpm: /etc/init.d/php-fpm start 4. 上传 wordpress 网站代码 # 解压包到nginx发布目录： tar xf wordpress-4.9.4-zh_CN.tar.gz -C /usr/local/nginx/html/ chown nginx. -R /usr/local/nginx/html/wordpress/ 5. 创建 wordpress 虚拟主机 # 指定应用的虚拟主机目录(主配置文件http指令块下添加)： include vhost/*.conf; # 创建虚拟主机目录： mkdir -p /usr/local/nginx/conf/vhost # 创建虚拟主机配置文件： vim /usr/local/nginx/conf/vhost/blog.wordpress.com.conf server { listen 80; server_name blog.wordpress.com; #charset koi8-r; access_log logs/wordpress.access.log; location / { root html/wordpress; index index.php index.html index.htm; } #error_page 404 /404.html; # redirect server error pages to the static page /50x.html # error_page 500 502 503 504 /50x.html; location = /50x.html { root html; } location ~ \\.php$ { root html/wordpress; fastcgi_pass 127.0.0.1:9000; fastcgi_index index.php; fastcgi_param SCRIPT_FILENAME $document_root$fastcgi_script_name; include fastcgi_params; } } 6. 创建数据库 # 启动数据库服务： /etc/init.d/mysqld start # 进入数据库创建数据库，并授权： MariaDB [(none)]> create database wordpress charset utf8; Query OK, 1 row affected (0.00 sec) MariaDB [(none)]> grant all on wordpress.* to \"wordpress\"@localhost identified by \"123456\"; Query OK, 0 rows affected (0.10 sec) MariaDB [(none)]> flush privileges; Query OK, 0 rows affected (0.00 sec) 7. 访问 wordpress blog.wordpress.com 在物理机做好 hosts 解析192.168.75.134 blog.wordpress.com bbs.discuz.com 8. 创建 discuz 虚拟主机配置文件 # 切换到vhost目录： cp blog.wordpress.com.conf bbs.discuz.com.conf # 修改域名和路径： server { listen 80; server_name bbs.discuz.com; #charset koi8-r; access_log logs/discuz.access.log main; location / { root html/discuz/upload; index index.php index.html index.htm; } #error_page 404 /404.html; # redirect server error pages to the static page /50x.html # error_page 500 502 503 504 /50x.html; location = /50x.html { root html; } location ~ \\.php$ { root html/discuz/upload; fastcgi_pass 127.0.0.1:9000; fastcgi_index index.php; fastcgi_param SCRIPT_FILENAME $document_root$fastcgi_script_name; include fastcgi_params; } } 9. 上传网站代码 # 解压： unzip Discuz_X3.1_SC_UTF8.zip -d /usr/local/nginx/html/discuz/ # 授权： chown nginx. -R /usr/local/nginx/html/discuz/ 10. 创建数据库 MariaDB [(none)]> create database discuz charset utf8; Query OK, 1 row affected (0.00 sec) MariaDB [(none)]> grant all on discuz.* to \"discuz\"@\"%\" identified by \"123456\"; Query OK, 0 rows affected (0.00 sec) MariaDB [(none)]> flush privileges; Query OK, 0 rows affected (0.00 sec) 11. 访问 discuz bbs.discuz.com By xiaobei，使用知识共享 署名-相同方式共享 4.0协议发布            此页面修订于： 2020-08-15 09:39:51 "},"book/technology/linux/Special-lecture/分布式LNMP高性能服务器.html":{"url":"book/technology/linux/Special-lecture/分布式LNMP高性能服务器.html","title":"分布式 LNMP 高性能服务器","keywords":"","body":"分布式 LNMP 高性能服务器 By xiaobei，使用知识共享 署名-相同方式共享 4.0协议发布            此页面修订于： 2020-08-15 09:39:51 "},"book/technology/linux/Special-lecture/LNMP+redis高性能服务器.html":{"url":"book/technology/linux/Special-lecture/LNMP+redis高性能服务器.html","title":"LNMP+redis 高性能服务器","keywords":"","body":"LNMP+redis 高性能服务器 By xiaobei，使用知识共享 署名-相同方式共享 4.0协议发布            此页面修订于： 2020-08-15 09:39:51 "},"book/technology/linux/Special-lecture/redis数据库主从哨兵模式.html":{"url":"book/technology/linux/Special-lecture/redis数据库主从哨兵模式.html","title":"redis 数据库主从哨兵模式","keywords":"","body":"redis 数据库主从哨兵模式 By xiaobei，使用知识共享 署名-相同方式共享 4.0协议发布            此页面修订于： 2020-08-15 09:39:51 "},"book/technology/linux/Special-lecture/zabbix监控入门.html":{"url":"book/technology/linux/Special-lecture/zabbix监控入门.html","title":"zabbix 监控入门","keywords":"","body":"zabbix 监控入门 By xiaobei，使用知识共享 署名-相同方式共享 4.0协议发布            此页面修订于： 2020-08-15 09:39:51 "},"book/technology/linux/Special-lecture/zabbix自定义监控项，触发器动作.html":{"url":"book/technology/linux/Special-lecture/zabbix自定义监控项，触发器动作.html","title":"zabbix 自定义监控项，触发器动作","keywords":"","body":"zabbix 自定义监控项，触发器动作 By xiaobei，使用知识共享 署名-相同方式共享 4.0协议发布            此页面修订于： 2020-08-15 09:39:51 "},"book/technology/linux/Special-lecture/zabbix分布式应用，微信报警.html":{"url":"book/technology/linux/Special-lecture/zabbix分布式应用，微信报警.html","title":"zabbix 分布式应用，微信报警","keywords":"","body":"zabbix 分布式应用，微信报警 By xiaobei，使用知识共享 署名-相同方式共享 4.0协议发布            此页面修订于： 2020-08-15 09:39:51 "},"book/technology/linux/Special-lecture/tomcat服务器实战.html":{"url":"book/technology/linux/Special-lecture/tomcat服务器实战.html","title":"tomcat服务器实战","keywords":"","body":"tomcat服务器实战 By xiaobei，使用知识共享 署名-相同方式共享 4.0协议发布            此页面修订于： 2020-08-15 09:39:51 "},"book/technology/linux/Special-lecture/SHELL编程入门&案例实战.html":{"url":"book/technology/linux/Special-lecture/SHELL编程入门&案例实战.html","title":"SHELL编程入门&案例实战","keywords":"","body":"SHELL 编程入门&案例实战 Linux 技术学习的重点和方法 1 学习 Linux 技术，学习重点不是 Linux 系统简介、系统安装、命令操作、目录功能、配置 IP、用户权限等，学习重点是基于 Linux 平台掌握各个软件服务、应用程序： NTP、DHCP、NFS、Vsftpd、Samba、Apache、Nginx、MYSQL、Mariadb、PHP、Tomcat、Rsync、Redis、Mycat、LVS、Keepalived、MQ、ZK、Haproxy、ES、ELK、Jenkins、SVN、GIT、Docker、K8S、Openstack； 2 作为运维人员，如何才能学好 Linux 软件服务、应用程序，有哪些学习技巧或者步骤方法呢？学习软件服务具体哪方面的内容呢？  掌握软件服务的功能、应用的场景和场合、实现企业哪些需求；  熟悉软件服务的工作原理、工作的流程，是如何对外服务的；  独立安装、部署软件服务，并且日常管理、启动、停止、升级；  掌握软件服务的目录功能、配置文件每个参数的含义；  能够对软件服务、应用程序配置文件参数进行优化、调整；  独立维护软件服务、应用程序日常的故障、第一时间解决故障。 SHELL 编程概念剖析 SHELL 是什么  用户默认登陆 Linux 系统（Linux 内核+SHELL 程序）之后，是不能直接操作 Linux 内核（Linux 操作系统），跟 Linux 内核是不能直接联系的，需要借助 SHELL 程序来实现连接，SHELL 程序也被称为 SHELL 外壳，是附属在 Linux 内核的外层的。  SHELL 是用户使用者和 Linux 内核之间的沟通桥梁，SHELL 可以接收用户输入的指令，SHELL 将接收到的指令传递给 Linux 内核，Linux 内核处理完成之后，会将处理的数据返回给 SHELL，SHELL 将数据处理最终返回给用户终端。  SHELL 是外壳程序，SHELL 也被称为命令解释器，是附属在 Linux 内核外层，负责接收用户输入的 Linux 指令的，同时将指令传递给 Linux 内核的，SHELL 外壳程序也有很多的种类，默认 Linux 操作系统自带 SHELL 程序：BASH。 SHELL 编程的概念?  SHELL 编程主要是将用户操作的单个、多个 Linux 指令，按照一定的逻辑关系、顺序，堆积在文本文件（脚本文件）中，脚本文件中所有的 Linux 指令最终会以特定 SHELL 解释器（BASH）去执行，从而完成企业中某个具体的业务需求。 3 SHELL 编程意义？  SHELL 编程主要是为了将手工操作的重复、繁琐的 Linux 指令、任务，变成流程化、简单化、自动化，以提高运维人员工作效率，减轻运维人员的工作量，加快企业自动化运维的脚步进程。 SHELL 编程开发 Nginx WEB 一键部署脚本（思路剖析）  从 Nginx 官网下载 Nginx 软件包稳定版本：nginx-1.16.0.tar.gz；  通过 tar 工具解压软件包，tar -xzvf nginx-1.16.0.tar.gz；  Cd 切换至解压源代码目录：cd nginx-1.16.0/；  解决编译 Nginx 软件服务依赖环境、库文件、GCC 编译器；  预编译，./configure --prefix=/usr/local/nginx/ --user=www --group=www --with-http_stub_status_module  编译，make  安装，make install  启动，/usr/local/nginx/sbin/nginx  查看 Nginx 进程，ps -ef|grep nginx  查看 Nginx 监听端口，netstat -tnlp|grep 80  关闭 selinux 和开启、关闭防火墙规则：setenforce 0； 4、SHELL 编程开发 Nginx WEB 一键部署脚本（v1 版本） #!/bin/bash #2020年8月15日21:42:51 #auto install nginx web #by author xiaobei ######################## yum install -y wget gzip net-tools make gcc yum install -y pcre pcre-devel zlib-devel wget -c http://nginx.org/download/nginx-1.16.0.tar.gz ls -l nginx-1.16.0.tar.gz tar -xzvf nginx-1.16.0.tar.gz cd nginx-1.16.0/ useradd -s /sbin/nologin www -M ./configure --prefix=/usr/local/nginx --user=www --group=www --with-http_stub_status_module make make install ls -l /usr/local/nginx/ /usr/local/nginx/sbin/nginx ps -ef|grep nginx netstat -tnlp|grep 80 setenforce 0 systemctl stop firewalld.service SHELL 编程开发 Nginx WEB 一键部署脚本（v2 版本） #!/bin/bash #2020年8月15日21:42:51 #auto install nginx web #by author xiaobei ######################## NGX_VER=\"1.15.0\" NGX_SRC=\"nginx-$NGX_VER\" NGX_YUM=\"yum install -y\" NGX_DIR=\"/data/app/nginx\" NGX_SOFT=\"nginx-${NGX_VER}.tar.gz\" NGX_URL=\"http://nginx.org/download\" NGX_ARGS=\"--user=www --group=www --with-http_stub_status_module --with-http_mail_module\" $NGX_YUM wget gzip net-tools make gcc $NGX_YUM pcre pcre-devel zlib-devel wget -c $NGX_URL/$NGX_SOFT ls -l $NGX_SOFT tar -xzvf $NGX_SOFT cd $NGX_SRC/ useradd -s /sbin/nologin www -M ./configure --prefix=$NGX_DIR $NGX_ARGS make make install ls -l $NGX_DIR $NGX_DIR/sbin/nginx ps -ef|grep nginx netstat -tnlp|grep 80 setenforce 0 systemctl stop firewalld.service By xiaobei，使用知识共享 署名-相同方式共享 4.0协议发布            此页面修订于： 2020-08-15 09:39:51 "},"book/technology/linux/Special-lecture/SHELL编程变量&if实战.html":{"url":"book/technology/linux/Special-lecture/SHELL编程变量&if实战.html","title":"SHELL编程变量&if实战","keywords":"","body":"SHELL编程变量&if实战 By xiaobei，使用知识共享 署名-相同方式共享 4.0协议发布            此页面修订于： 2020-08-15 09:39:51 "},"book/technology/linux/Special-lecture/SHELL编程if语句和for循环.html":{"url":"book/technology/linux/Special-lecture/SHELL编程if语句和for循环.html","title":"SHELL编程if语句和for循环","keywords":"","body":"SHELL编程if语句和for循环 By xiaobei，使用知识共享 署名-相同方式共享 4.0协议发布            此页面修订于： 2020-08-15 09:39:51 "},"book/technology/linux/Special-lecture/SHELL编程For&While.html":{"url":"book/technology/linux/Special-lecture/SHELL编程For&While.html","title":"SHELL编程For&While实战","keywords":"","body":"SHELL编程For&While实战 By xiaobei，使用知识共享 署名-相同方式共享 4.0协议发布            此页面修订于： 2020-08-15 09:39:51 "},"book/technology/linux/Special-lecture/SHELL编程Case&While实战.html":{"url":"book/technology/linux/Special-lecture/SHELL编程Case&While实战.html","title":"SHELL编程Case&While实战","keywords":"","body":"SHELL编程Case&While实战 By xiaobei，使用知识共享 署名-相同方式共享 4.0协议发布            此页面修订于： 2020-08-15 09:39:51 "},"book/technology/linux/Special-lecture/SHELL编程Nginx虚拟主机实战.html":{"url":"book/technology/linux/Special-lecture/SHELL编程Nginx虚拟主机实战.html","title":"SHELL编程Nginx虚拟主机实战","keywords":"","body":"SHELL编程Nginx虚拟主机实战 By xiaobei，使用知识共享 署名-相同方式共享 4.0协议发布            此页面修订于： 2020-08-15 09:39:51 "},"book/technology/linux/Special-lecture/SHELL编程Find案例实战.html":{"url":"book/technology/linux/Special-lecture/SHELL编程Find案例实战.html","title":"SHELL编程Find案例实战","keywords":"","body":"SHELL编程Find案例实战 By xiaobei，使用知识共享 署名-相同方式共享 4.0协议发布            此页面修订于： 2020-08-15 09:39:51 "},"book/technology/linux/Special-lecture/SHELL编程Sed&Grep案例实战.html":{"url":"book/technology/linux/Special-lecture/SHELL编程Sed&Grep案例实战.html","title":"SHELL编程Sed&Grep案例实战","keywords":"","body":"SHELL编程Sed&Grep案例实战 By xiaobei，使用知识共享 署名-相同方式共享 4.0协议发布            此页面修订于： 2020-08-15 09:39:51 "},"book/technology/linux/Special-lecture/SHELL编程Grep&Awk案例实战.html":{"url":"book/technology/linux/Special-lecture/SHELL编程Grep&Awk案例实战.html","title":"SHELL编程Grep&Awk案例实战","keywords":"","body":"SHELL编程Grep&Awk案例实战 By xiaobei，使用知识共享 署名-相同方式共享 4.0协议发布            此页面修订于： 2020-08-15 09:39:51 "},"book/technology/linux/Special-lecture/LVS+Keepalived高可用实战.html":{"url":"book/technology/linux/Special-lecture/LVS+Keepalived高可用实战.html","title":"LVS+Keepalived高可用实战","keywords":"","body":"LVS+Keepalived高可用实战 By xiaobei，使用知识共享 署名-相同方式共享 4.0协议发布            此页面修订于： 2020-08-15 09:39:51 "},"book/technology/linux/Special-lecture/Nginx+Keepalived高可用企业实战.html":{"url":"book/technology/linux/Special-lecture/Nginx+Keepalived高可用企业实战.html","title":"Nginx+Keepalived高可用企业实战","keywords":"","body":"Nginx+Keepalived高可用企业实战 By xiaobei，使用知识共享 署名-相同方式共享 4.0协议发布            此页面修订于： 2020-08-15 09:39:51 "},"book/technology/linux/Special-lecture/LVS+Keepalived高可用企业实战.html":{"url":"book/technology/linux/Special-lecture/LVS+Keepalived高可用企业实战.html","title":"LVS+Keepalived高可用企业实战","keywords":"","body":"LVS+Keepalived高可用企业实战 By xiaobei，使用知识共享 署名-相同方式共享 4.0协议发布            此页面修订于： 2020-08-15 09:39:51 "},"book/technology/linux/Special-lecture/Docker虚拟化技术实战.html":{"url":"book/technology/linux/Special-lecture/Docker虚拟化技术实战.html","title":"Docker虚拟化技术实战","keywords":"","body":"Docker虚拟化技术实战 By xiaobei，使用知识共享 署名-相同方式共享 4.0协议发布            此页面修订于： 2020-08-15 09:39:51 "},"book/technology/linux/command-encyclopedia/1.file-management/":{"url":"book/technology/linux/command-encyclopedia/1.file-management/","title":"1.文件管理","keywords":"","body":"1.文件管理 内容来自网络，仅做学习研究使用，如有侵权请联系删除 By xiaobei，使用知识共享 署名-相同方式共享 4.0协议发布            此页面修订于： 2020-08-15 09:39:51 "},"book/technology/linux/command-encyclopedia/1.file-management/ls-显示指定工作目录下的内容及属性信息.html":{"url":"book/technology/linux/command-encyclopedia/1.file-management/ls-显示指定工作目录下的内容及属性信息.html","title":"ls-显示指定工作目录下的内容及属性信息","keywords":"","body":"ls-显示指定工作目录下的内容及属性信息 ls 命令是 Linux 下最常用的指令之一。ls 命令为英文单词 list 的缩写，正如英文单词 list 的意思，其功能是列出指定目录下的内容及其相关属性信息。 默认状态下，ls 命令会列出当前目录的内容。而带上参数后，我们可以用 ls 做更多的事情。作为最基础同时又是使用频率很高的命令，我们很有必要搞清楚 ls 命令的用法，那么接下来一起看看吧！ 语法格式: ls [选项][文件] 常用参数 参数 注释 -a 显示所有文件及目录 (包括以“.”开头的隐藏文件) -l 使用长格式列出文件及目录信息 -r 将文件以相反次序显示(默认依英文字母次序) -t 根据最后的修改时间排序 -A 同 -a ，但不列出 “.” (当前目录) 及 “..” (父目录) -S 根据文件大小排序 -R 递归列出所有子目录 参考实例 列出所有文件(包括隐藏文件) [root@xiaobei ~]# ls -a 列出文件的详细信息 [root@xiaobei ~]# ls -l 列出根目录(/)下的所有目录 [root@xiaobei ~]# ls / 列出当前工作目录下所有名称是 “s” 开头的文件 [root@xiaobei ~]# ls -ltr s* 列出 /bin 目录下的所有目录及文件的详细信息 [root@xiaobei ~]# ls -lR /bin 列出当前工作目录下所有文件及目录并以文件的大小进行排序 [root@xiaobei ~]# ls -AS By xiaobei，使用知识共享 署名-相同方式共享 4.0协议发布            此页面修订于： 2020-08-15 09:39:51 "},"book/technology/linux/command-encyclopedia/1.file-management/mkdir–创建目录.html":{"url":"book/technology/linux/command-encyclopedia/1.file-management/mkdir–创建目录.html","title":"mkdir–创建目录","keywords":"","body":"mkdir–创建目录 mkdir 命令是“make directories”的缩写，用来创建目录。 注意：默认状态下，如果要创建的目录已经存在，则提示已存在，而不会继续创建目录。 所以在创建目录时，应保证新建的目录与它所在目录下的文件没有重名。 mkdir 命令还可以同时创建多个目录。 语法格式 : mkdir [参数][目录] 常用参数 参数 注释 -p 递归创建多级目录 -m 建立目录的同时设置目录的权限 -z 设置安全上下文 -v 显示目录创建过程 参考实例 # 在工作目录下，建立一个名为 dir 的子目录 [root@xiaobei xiaobei]# mkdir dir # 在目录/home/xiaobei/dir下建立子目录dir，并且设置文件属主有读、写和执行权限，其他人无权访问 [root@xiaobei xiaobei]# mkdir -m 700 /home/xiaobei/dir/dir # 同时创建子目录dir1，dir2，dir3 [root@xiaobei dir]# mkdir dir1 dir2 dir3 # 递归创建目录 [root@xiaobei dir]# mkdir -p /home/xiaobei/dir/dd/dir By xiaobei，使用知识共享 署名-相同方式共享 4.0协议发布            此页面修订于： 2020-08-15 09:39:51 "},"book/technology/linux/command-encyclopedia/1.file-management/cp-复制文件或目录.html":{"url":"book/technology/linux/command-encyclopedia/1.file-management/cp-复制文件或目录.html","title":"cp-复制文件或目录","keywords":"","body":"cp-复制文件或目录 cp 命令可以理解为英文单词 copy 的缩写，其功能为复制文件或目录。 cp 命令可以将多个文件复制到一个具体的文件名或一个已经存在的目录下，也可以同时复制多个文件到一个指定的目录中。 语法格式：cp [参数][文件] 常用参数 参数 注释 -f 若目标文件已存在，则会直接覆盖原文件 -i 若目标文件已存在，则会询问是否覆盖 -p 保留源文件或目录的所有属性 -r 递归复制文件和目录 -d 当复制符号连接时，把目标文件或目录也建立为符号连接，并指向与源文件或目录连接的原始文件或目录 -l 对源文件建立硬连接，而非复制文件 -s 对源文件建立符号连接，而非复制文件 -b 覆盖已存在的文件目标前将目标文件备份 -v 详细显示 cp 命令执行的操作过程 -a 等价于“dpr”选项 参考实例 # 复制目录 [root@xiaobei xiaobei]# cp -R dir /home/xiaobei/dir2 # 将文件xiaobei1改名为xiaobei2 [root@xiaobei xiaobei]# cp -f /home/xiaobei/dir/xiaobei1.txt /home/xiaobei/dir/xiaobei2.txt # 复制多个文件 [root@xiaobei xiaobei]# cp -r dir dir2 # 交互式地将目录 /usr/linuxcool 中的所有.c文件复制到目录 dir 中 [root@xiaobei xiaobei]# cp -r dir/*.txt dir2 By xiaobei，使用知识共享 署名-相同方式共享 4.0协议发布            此页面修订于： 2020-08-15 09:39:51 "},"book/technology/linux/command-encyclopedia/1.file-management/pwd-显示当前目录.html":{"url":"book/technology/linux/command-encyclopedia/1.file-management/pwd-显示当前目录.html","title":"pwd-显示当前目录","keywords":"","body":"pwd-显示当前目录 pwd 命令是“print working directory”中每个单词的首字母缩写，其功能正如所示单词一样，为打印工作目录，即显示当前工作目录的绝对路径。 在实际工作中，我们经常会在不同目录之间进行切换，为了防止“迷路”，我们可以使用 pwd 命令快速查看当前我们所在的目录路径。 语法格式: pwd [参数] 常用参数 参数 注释 -L 显示逻辑路径 参考实例 [root@xiaobei dir]# pwd /home/xiaobei/dir By xiaobei，使用知识共享 署名-相同方式共享 4.0协议发布            此页面修订于： 2020-08-15 09:39:51 "},"book/technology/linux/command-encyclopedia/1.file-management/mv-移动或改名.html":{"url":"book/technology/linux/command-encyclopedia/1.file-management/mv-移动或改名.html","title":"mv-移动或改名","keywords":"","body":"mv-移动或改名 mv 命令是“move”单词的缩写，其功能大致和英文含义一样，可以移动文件或对其改名。 这是一个使用频率超高的文件管理命令，我们需要特别留意它与复制的区别：mv 与 cp 的结果不同。mv 命令好像文件“搬家”，文件名称发生改变，但个数并未增加。而 cp 命令是对文件进行复制操作，文件个数是有增加的。 语法格式：mv [参数] 常用参数 参数 注释 -i 若存在同名文件，则向用户询问是否覆盖 -f 覆盖已有文件时，不进行任何提示 -b 当文件存在时，覆盖前为其创建一个备份 -u 当源文件比目标文件新，或者目标文件不存在时，才执行移动此操作 参考实例 #将文件file_1重命名为file_2： [root@xiaobei dir]# mv file_1 file_2 # 将文件file移动到目录dir中 ： [root@xiaobei dir]# mv file /dir # 将目录dir1移动目录dir2中（前提是目录dir2已存在，若不存在则改名)： [root@xiaobei dir]# mv /dir1 /dir2 # 将目录dir1下的文件移动到当前目录下： [root@xiaobei dir]# mv /dir1/* . By xiaobei，使用知识共享 署名-相同方式共享 4.0协议发布            此页面修订于： 2020-08-15 09:39:51 "},"book/technology/linux/command-encyclopedia/1.file-management/touch-创建文件.html":{"url":"book/technology/linux/command-encyclopedia/1.file-management/touch-创建文件.html","title":"touch-创建文件","keywords":"","body":"touch-创建文件 touch 命令有两个功能：一是创建新的空文件，二是改变已有文件的时间戳属性。 touch 命令会根据当前的系统时间更新指定文件的访问时间和修改时间。如果文件不存在，将会创建新的空文件，除非指定了”-c”或”-h”选项。 注意：在修改文件的时间属性的时候，用户必须是文件的属主，或拥有写文件的访问权限。 语法格式：touch [参数][文件] 常用参数 参数 注释 -a 改变档案的读取时间记录 -m 改变档案的修改时间记录 -r 使用参考档的时间记录，与 --file 的效果一样 -c 不创建新文件 -d 设定时间与日期，可以使用各种不同的格式 -t 设定档案的时间记录，格式与 date 命令相同 --no-create 不创建新文件 --help 显示帮助信息 --version 列出版本讯息 参考实例 # 创建空文件 [root@xiaobei xiaobei]# touch file.txt # 批量创建文件 [root@xiaobei xiaobei]# touch file{1..5}.txt [root@xiaobei xiaobei]# ls file1.txt file2.txt file3.txt file4.txt file5.txt file.txt # 修改文件的access(访问)时间 [root@xiaobei xiaobei]# stat file.txt File: ‘file.txt’ Size: 0 Blocks: 0 IO Block: 4096 regular empty file Device: fd00h/64768d Inode: 16847736 Links: 1 Access: (0644/-rw-r--r--) Uid: ( 0/ root) Gid: ( 0/ root) Context: unconfined_u:object_r:home_root_t:s0 Access: 2020-07-02 18:56:34.099010059 +0800 Modify: 2020-07-02 18:56:34.099010059 +0800 Change: 2020-07-02 18:56:34.099010059 +0800 Birth: - [root@xiaobei xiaobei]# touch -a file.txt [root@xiaobei xiaobei]# stat file.txt File: ‘file.txt’ Size: 0 Blocks: 0 IO Block: 4096 regular empty file Device: fd00h/64768d Inode: 16847736 Links: 1 Access: (0644/-rw-r--r--) Uid: ( 0/ root) Gid: ( 0/ root) Context: unconfined_u:object_r:home_root_t:s0 Access: 2020-07-02 18:58:24.913003454 +0800 Modify: 2020-07-02 18:56:34.099010059 +0800 Change: 2020-07-02 18:58:24.913003454 +0800 Birth: - By xiaobei，使用知识共享 署名-相同方式共享 4.0协议发布            此页面修订于： 2020-08-15 09:39:51 "},"book/technology/linux/command-encyclopedia/1.file-management/userdel-删除用户.html":{"url":"book/technology/linux/command-encyclopedia/1.file-management/userdel-删除用户.html","title":"userdel-删除用户","keywords":"","body":"userdel-删除用户 userdel 命令用于删除指定的用户及与该用户相关的文件，英文全称即“user delete”。其实 userdel 命令实际上是修改了系统的用户账号文件 /etc/passwd、/etc/shadow 以及/etc/group 文件。这与 Linux 系统”一切操作皆文件”的思想正好吻合。 值得注意的是，但是如果有该要删除用户相关的进程正在运行，userdel 命令通常不会删除一个用户账号。如果确实必须要删除，可以先终止用户进程，然后再执行 userdel 命令进行删除。但是 userdel 命令也提供了一个面对该种情况的参数，即”-f”选项。 语法格式：userdel [参数][用户名] 常用参数 参数 注释 -f 强制删除用户账号 -r 删除用户主目录及其中的任何文件 -h 显示命令的帮助信息 参考实例 #删除用户，但不删除其家目录及文件： [root@xiaobei ~]# userdel www #删除用户，并将其家目录及文件一并删除： [root@xiaobei ~]# userdel -r www #强制删除用户： [root@xiaobei ~]# userdel -f www By xiaobei，使用知识共享 署名-相同方式共享 4.0协议发布            此页面修订于： 2020-08-15 09:39:51 "},"book/technology/linux/command-encyclopedia/1.file-management/ln-为文件创建链接.html":{"url":"book/technology/linux/command-encyclopedia/1.file-management/ln-为文件创建链接.html","title":"ln-为文件创建链接","keywords":"","body":"ln-为文件创建链接 ln 命令是 linux 系统中一个非常重要命令，英文全称是“link”，即链接的意思，它的功能是为某一个文件在另外一个位置建立一个同步的链接。 一种是 hard link，又称为硬链接；另一种是 symbolic link，又称为符号链接。 通俗一点理解，可以把硬链接当成源文件的副本，他和源文件一样的大小，但是事实上却不占任何空间。符号链接可以理解为类似 windows 一样的快捷方式。 符号链接 符号链接以路径的形式存在，类似于 Windows 操作系统中的快捷方式。 符号链接可以跨文件系统 ，硬链接不可以。 符号链接可以对一个不存在的文件名进行链接，硬链接不可以。 符号链接可以对目录进行链接，硬链接不可以。 硬链接 硬链接以文件副本的形式存在，但不占用实际空间。 硬链接不允许给目录创建硬链接。 硬链接只有在同一个文件系统中才能创建。 语法格式： ln [参数][源文件或目录] [目标文件或目录] 常用参数 参数 注释 -b 为每个已存在的目标文件创建备份文件 -d 此选项允许“root”用户建立目录的硬链接 -f 强制创建链接，即使目标文件已经存在 -n 把指向目录的符号链接视为一个普通文件 -i 交互模式，若目标文件已经存在，则提示用户确认进行覆盖 -s 对源文件建立符号链接，而非硬链接 -v 详细信息模式，输出指令的详细执行过程 参考实例 #为源文件file.txt创建硬链接file： [root@xiaobei xiaobei]# ln file.txt file #使用ln命令的“-s”参数来创建目录的符号链接，并使用ls命令来查看链接文件的详细信息： [root@xiaobei home]# ln -s xiaobei file [root@xiaobei home]# ls -l total 0 lrwxrwxrwx. 1 root root 7 Jul 2 19:16 file -> xiaobei drwxr-xr-x. 2 root root 119 Jul 2 19:14 xiaobei prw-r--r--. 1 root root 0 Jun 30 16:39 xiaobei.pipe #使用ln命令的“-v”参数来输出命令的详细执行过程： [root@xiaobei xiaobei]# ln -v file.txt file_1 ‘file_1’ => ‘file.txt’ #使用ln命令的“-b”命令来创建目标文件的备份文件，并使用ls命令来查看： [root@xiaobei xiaobei]# ln -b file.txt file [root@xiaobei xiaobei]# ls file file~ file_1 file1.txt file2.txt file3.txt file4.txt file5.txt file.txt By xiaobei，使用知识共享 署名-相同方式共享 4.0协议发布            此页面修订于： 2020-08-15 09:39:51 "},"book/technology/linux/command-encyclopedia/1.file-management/chattr-更改文件属性.html":{"url":"book/technology/linux/command-encyclopedia/1.file-management/chattr-更改文件属性.html","title":"chattr-更改文件属性","keywords":"","body":"chattr-更改文件属性 chattr 指令可改变 linux 文件系统的文件属性，通用格式为：+-=[aAcCdDeijsStTu] “ aAcCdDeijsStTu ” 表示可以赋予文件的新属性，这些属性共有以下几种模式: a：让文件或目录仅供附加用途； A：当一个具有“A”属性的文件被访问时，它的 atime 记录不会被修改； c：将文件或目录压缩后存放； d：将文件或目录排除在倾倒操作之外； i：不得任意更动文件或目录； j：如果文件系统安装有“data=order”或“data=writeback”选项，则具有“j”属性的文件在写入文件本身之前将其所有数据写入 ext 3 日志； s：当删除具有“s”属性集的文件时，其块将被归零并写回磁盘； S：当修改具有“S”属性集的文件时，更改将同步写入磁盘；这相当于应用于文件子集的“同步”挂载选项； u：当删除具有‘u’属性集的文件时，它的内容将被保存。 语法格式：chattr [参数][文件] 常用参数 参数 注释 -R 递归处理目录下的所有文件 -v 设置文件或目录版本 -V 显示指令执行过程 + 开启文件或目录的该项属性 -- 关闭文件或目录的该项属性 = 指定文件或目录的该项属性 参考实例 # 用chattr命令防止系统中某个关键文件被修改(加锁)： [root@xiaobei xiaobei]# chattr +i file.txt # 解锁： [root@xiaobei xiaobei]# chattr -i file.txt # 让某个文件只能往里面追加数据，但不能删除，适用于各种日志文件： [root@xiaobei xiaobei]# chattr +a file.txt By xiaobei，使用知识共享 署名-相同方式共享 4.0协议发布            此页面修订于： 2020-08-15 09:39:51 "},"book/technology/linux/command-encyclopedia/1.file-management/cd-切换目录.html":{"url":"book/technology/linux/command-encyclopedia/1.file-management/cd-切换目录.html","title":"cd-切换目录","keywords":"","body":"cd-切换目录 cd 命令是”change directory”中单词的首字母缩写，其英文释义是改变目录，所以该命令的功能是从当前目录切换到指定目录。 其中目录的路径可分为绝对路径和相对路径。若目录名称省略，则切换至使用者的用户目录(也就是刚登录时所在的目录)。 另外，“~”也表示为用户目录的意思，“.”则是表示目前所在的目录，“..”则表示当前目录位置的上一级目录。 语法格式：cd [参数][目录名] 常用参数 参数 注释 -P 如果切换的目标目录是一个符号链接，则直接切换到符号链接指向的目标目录 -L 如果切换的目标目录是一个符号链接，则直接切换到符号链接名所在的目录 -- 仅使用”-“选项时，当前目录将被切换到环境变量”OLDPWD”对应值的目录 ~ 切换至当前用户目录 .. 切换至当前目录位置的上一级目录 参考实例 # 后面补 By xiaobei，使用知识共享 署名-相同方式共享 4.0协议发布            此页面修订于： 2020-08-15 09:39:51 "},"book/technology/linux/command-encyclopedia/1.file-management/traceroute-追踪数据包在网络上的传输时的全部路径.html":{"url":"book/technology/linux/command-encyclopedia/1.file-management/traceroute-追踪数据包在网络上的传输时的全部路径.html","title":"traceroute-追踪数据包在网络上的传输时的全部路径","keywords":"","body":"traceroute-追踪数据包在网络上的传输时的全部路径 traceroute 命令用于追踪数据包在网络上的传输时的全部路径，它默认发送的数据包大小是 40 字节。通过 traceroute 我们可以知道信息从你的计算机到互联网另一端的主机是走的什么路径。当然每次数据包由某一同样的出发点（source）到达某一同样的目的地(destination)走的路径可能会不一样，但基本上来说大部分时候所走的路由是相同的。 traceroute 通过发送小的数据包到目的设备直到其返回，来测量其需要多长时间。一条路径上的每个设备 traceroute 要测 3 次。输出结果中包括每次测试的时间(ms)和设备的名称（如有的话）及其 ip 地址。 语法格式：traceroute [参数][域名或者ip] 常用参数 参数 注释 -d 使用 Socket 层级的排错功能 -f 设置第一个检测数据包的存活数值 TTL 的大小 -F 设置勿离断位 -g 设置来源路由网关，最多可设置 8 个 -i 使用指定的网络界面送出数据包 -I 使用 ICMP 回应取代 UDP 资料信息 -m 设置检测数据包的最大存活数值 TTL 的大小 -n 直接使用 IP 地址而非主机名称 -p 设置 UDP 传输协议的通信端口 -r 忽略普通的 Routing Table，直接将数据包送到远端主机上 -s 设置本地主机送出数据包的 IP 地址 -t 设置检测数据包的 TOS 数值 -v 详细显示指令的执行过程 -w 设置等待远端主机回报的时间 -x 开启或关闭数据包的正确性检验 参考实例 # 后面补 By xiaobei，使用知识共享 署名-相同方式共享 4.0协议发布            此页面修订于： 2020-08-15 09:39:51 "},"book/technology/linux/command-encyclopedia/1.file-management/cksum-校验文件.html":{"url":"book/technology/linux/command-encyclopedia/1.file-management/cksum-校验文件.html","title":"cksum-校验文件","keywords":"","body":"cksum-校验文件 cksum 命令用于检查文件的 CRC 是否正确， 确保文件从一个系统传输到另一个系统的过程中的正确性 。循环冗余校验法 （ CRC ）是一种排错检查方式，该校验法的标准由 CCITT 所指定，至少可检测到 99.998%的已知错误。 这种方法要求校验和在源系统和目的系统中分别被计算出来，之后进行比较，如果校验和相等，则认为该文件传输正确。若不指定任何文件名称或是所给予的文件名为”-“，则指令”cksum”会从标准输入设备中读取数据。 语法格式：cksum [参数][文件] 常用参数 参数 注释 --help 在线帮助 --version 显示版本信息 参考实例 # 后面补 By xiaobei，使用知识共享 署名-相同方式共享 4.0协议发布            此页面修订于： 2020-08-15 09:39:51 "},"book/technology/linux/command-encyclopedia/1.file-management/locate-快速查找文件或目录.html":{"url":"book/technology/linux/command-encyclopedia/1.file-management/locate-快速查找文件或目录.html","title":"locate-快速查找文件或目录","keywords":"","body":"locate-快速查找文件或目录 locate 命令其实是 find -name 的另一种写法，但是要比后者快得多，原因在于它不搜索具体目录，而是搜索一个数据库/var/lib/locatedb，值得注意的是：版本不同，会有所不同。有的版本位置是 /var/lib/mlocate/mlocatedb ，还有的是/var/lib/slocate/slocate.db ，这个数据库中含有本地所有文件信息。 Linux 系统自动创建这个数据库，并且每天自动更新一次，所以使用 locate 命令查不到最新变动过的文件。为了避免这种情况，可以在使用 locate 之前，先使用 updatedb 命令，手动更新数据库。 语法格式：locate [参数][文件] 常用参数 参数 注释 -d或--database= 指定数据库所在的目录 --help 显示帮助 --version 显示版本信息 参考实例 # 后面补 By xiaobei，使用知识共享 署名-相同方式共享 4.0协议发布            此页面修订于： 2020-08-15 09:39:51 "},"book/technology/linux/command-encyclopedia/1.file-management/wc-统计文件的字节数、字数、行数.html":{"url":"book/technology/linux/command-encyclopedia/1.file-management/wc-统计文件的字节数、字数、行数.html","title":"wc-统计文件的字节数、字数、行数","keywords":"","body":"wc-统计文件的字节数、字数、行数 wc 命令统计指定文件中的字节数、字数、行数，并将统计结果显示输出。利用 wc 指令我们可以计算文件的 Byte 数、字数或是列数，若不指定文件名称，或是所给予的文件名为“-”，则 wc 指令会从标准输入设备读取数据。wc 同时也给出所指定文件的总统计数。 语法格式：wc [参数][文件] 常用参数 参数 注释 -w 统计字数，或--words：只显示字数。一个字被定义为由空白、跳格或换行字符分隔的字符串 -c 统计字节数，或--bytes 或--chars：只显示 Bytes 数 -l 统计行数，或--lines：只显示列数 -m 统计字符数 -L 打印最长行的长度 --help 显示帮助信息 --version 显示版本信息 参考实例 # 后面补 By xiaobei，使用知识共享 署名-相同方式共享 4.0协议发布            此页面修订于： 2020-08-15 09:39:51 "},"book/technology/linux/command-encyclopedia/1.file-management/lsattr-显示文件隐藏属性.html":{"url":"book/technology/linux/command-encyclopedia/1.file-management/lsattr-显示文件隐藏属性.html","title":"lsattr-显示文件隐藏属性","keywords":"","body":"lsattr-显示文件隐藏属性 lsattr 命令的英文全称即“list attribute”，用于查看特定设备或特定文件在 Linux 第二扩展文件系统上的特有属性信息 。该命令常与 chattr 一起使用，chattr 命令用于改变文件或目录的隐藏属性，而 lsattr 命令则用于查看其属性 。 语法格式：lsattr [参数][文件] 常用参数 参数 注释 -a 列出目录中的所有文件，包括隐藏文件 -d 只显示目录名称 -R 递归地处理指定目录下的所有文件及子目录 -v 显示文件或目录版本 -V 显示版本信息 -D 显示属性的名称、默认值 -E 显示从用户设备数据库中获得属性的当前值 参考实例 # 后面补 By xiaobei，使用知识共享 署名-相同方式共享 4.0协议发布            此页面修订于： 2020-08-15 09:39:51 "},"book/technology/linux/command-encyclopedia/1.file-management/whereis-显示命令及相关文件的路径.html":{"url":"book/technology/linux/command-encyclopedia/1.file-management/whereis-显示命令及相关文件的路径.html","title":"whereis-显示命令及相关文件的路径","keywords":"","body":"whereis-显示命令及相关文件的路径 whereis 命令用来定位命令的二进制程序、源代码文件和 man 手册页等相关文件的路径。 whereis 命令查找速度非常快，因为它不是在磁盘中乱找，而是在一个数据库中查询; 数据库是 linux 系统自动创建的，包含有本地所有文件的信息，并且每天通过自动执行 updatedb 命令更新一次。正因为这样，whereis 命令的搜索结果有时候会不准确，比如刚添加的文件可能搜不到， 原因就是该数据库文件没有被更新。 语法格式：whereis [参数][命令名] 常用参数 参数 注释 -b 查找二进制程序或命令 -B 从指定目录下 查找二进制程序或命令 -m 查找 man 手册文件 -M 从指定目录下 查找 man 手册文件 -s 只查找源代码文件 -S 从指定目录下 查找源代码文件 参考实例 # 后面补 By xiaobei，使用知识共享 署名-相同方式共享 4.0协议发布            此页面修订于： 2020-08-15 09:39:51 "},"book/technology/linux/command-encyclopedia/1.file-management/sort-排序文件并输出.html":{"url":"book/technology/linux/command-encyclopedia/1.file-management/sort-排序文件并输出.html","title":"sort-排序文件并输出","keywords":"","body":"sort-排序文件并输出 sort 命令是在 Linux 里非常有用，它将文件进行排序，并将排序结果标准输出。sort 命令既可以从特定的文件，也可以从 stdin 中获取输入。 语法格式：sort [参数][文件] 常用参数 参数 注释 -b 忽略每行前面开始出的空格字符 -c 检查文件是否已经按照顺序排序 -d 排序时，处理英文字母、数字及空格字符外，忽略其他的字符 -f 排序时，将小写字母视为大写字母 -i 排序时，除了 040 至 176 之间的 ASCII 字符外，忽略其他的字符 -m 将几个排序号的文件进行合并 -M 将前面 3 个字母依照月份的缩写进行排序 -n 依照数值的大小排序 -o 将排序后的结果存入制定的文件 -r 以相反的顺序来排序 -t 指定排序时所用的栏位分隔字符 -k 指定需要排序的栏位 参考实例 # 后面补 By xiaobei，使用知识共享 署名-相同方式共享 4.0协议发布            此页面修订于： 2020-08-15 09:39:51 "},"book/technology/linux/command-encyclopedia/1.file-management/less-分页显示工具.html":{"url":"book/technology/linux/command-encyclopedia/1.file-management/less-分页显示工具.html","title":"less-分页显示工具","keywords":"","body":"less-分页显示工具 浏览文字档案的内容，用 less 命令显示文件时，PageUp 键向上翻页，PageDown 键向下翻页，要退出 less 程序，应按 Q 键。 less 的作用与 more 十分相似，不同点为 less 命令允许用户向前或向后浏览文件，而 more 命令只能向前浏览 。 语法格式：less [参数][文件] 常用参数 参数 注释 -b 置缓冲区的大小 -e 当文件显示结束后，自动离开 -f 强迫打开特殊文件，例如外围设备代号、目录和二进制文件 -g 只标志最后搜索的关键词 -i 忽略搜索时的大小写 -m 显示类似 more 命令的百分比 -N 显示每行的行号 -o 将 less 输出的内容在指定文件中保存起来 -Q 不使用警告音 -s 显示连续空行为一行 -S 在单行显示较长的内容，而不换行显示 -x 将 TAB 字符显示为指定个数的空格字符 参考实例 # 后面补 By xiaobei，使用知识共享 署名-相同方式共享 4.0协议发布            此页面修订于： 2020-08-15 09:39:51 "},"book/technology/linux/command-encyclopedia/2.documents-editing/":{"url":"book/technology/linux/command-encyclopedia/2.documents-editing/","title":"2.文档编辑","keywords":"","body":"2.文档编辑 内容来自网络，仅做学习研究使用，如有侵权请联系删除 By xiaobei，使用知识共享 署名-相同方式共享 4.0协议发布            此页面修订于： 2020-08-15 09:39:51 "},"book/technology/linux/command-encyclopedia/3.system-management/":{"url":"book/technology/linux/command-encyclopedia/3.system-management/","title":"3.系统管理","keywords":"","body":"3.系统管理 内容来自网络，仅做学习研究使用，如有侵权请联系删除 By xiaobei，使用知识共享 署名-相同方式共享 4.0协议发布            此页面修订于： 2020-08-15 09:39:51 "},"book/technology/linux/command-encyclopedia/4.disk-management/":{"url":"book/technology/linux/command-encyclopedia/4.disk-management/","title":"4.磁盘管理","keywords":"","body":"4.磁盘管理 内容来自网络，仅做学习研究使用，如有侵权请联系删除 By xiaobei，使用知识共享 署名-相同方式共享 4.0协议发布            此页面修订于： 2020-08-15 09:39:51 "},"book/technology/linux/command-encyclopedia/5.file-transfer/":{"url":"book/technology/linux/command-encyclopedia/5.file-transfer/","title":"5.文件传输","keywords":"","body":"5.文件传输 内容来自网络，仅做学习研究使用，如有侵权请联系删除 By xiaobei，使用知识共享 署名-相同方式共享 4.0协议发布            此页面修订于： 2020-08-15 09:39:51 "},"book/technology/linux/command-encyclopedia/6.network-communication/":{"url":"book/technology/linux/command-encyclopedia/6.network-communication/","title":"6.网络通讯","keywords":"","body":"6.网络通讯 内容来自网络，仅做学习研究使用，如有侵权请联系删除 By xiaobei，使用知识共享 署名-相同方式共享 4.0协议发布            此页面修订于： 2020-08-15 09:39:51 "},"book/technology/linux/command-encyclopedia/7.quipment-management/":{"url":"book/technology/linux/command-encyclopedia/7.quipment-management/","title":"7.设备管理","keywords":"","body":"7.设备管理 内容来自网络，仅做学习研究使用，如有侵权请联系删除 By xiaobei，使用知识共享 署名-相同方式共享 4.0协议发布            此页面修订于： 2020-08-15 09:39:51 "},"book/technology/linux/command-encyclopedia/8.backup-compression/":{"url":"book/technology/linux/command-encyclopedia/8.backup-compression/","title":"8.备份压缩","keywords":"","body":"8.备份压缩 内容来自网络，仅做学习研究使用，如有侵权请联系删除 By xiaobei，使用知识共享 署名-相同方式共享 4.0协议发布            此页面修订于： 2020-08-15 09:39:51 "},"book/technology/linux/command-encyclopedia/9.other-command/":{"url":"book/technology/linux/command-encyclopedia/9.other-command/","title":"9.其他命令","keywords":"","body":"9.其他命令 内容来自网络，仅做学习研究使用，如有侵权请联系删除 By xiaobei，使用知识共享 署名-相同方式共享 4.0协议发布            此页面修订于： 2020-08-15 09:39:51 "},"book/technology/go/go环境及goland快捷键.html":{"url":"book/technology/go/go环境及goland快捷键.html","title":"go 环境及 goland 快捷键","keywords":"","body":"GoLand 常用快捷键 查找快捷键位置：File->Settings->Keymap 1、查询快捷键 CTRL+N 查找类 CTRL+SHIFT+N 查找文件 CTRL+SHIFT+ALT+N 查找类中的方法或变量 CTRL+B 快速打开光标处的类或方法 CTRL+ALT+B 找所有的子类 CTRL+SHIFT+B 找变量的类 CTRL+G 定位行 CTRL+F 在当前窗口查找文本 CTRL+SHIFT+F 在指定窗口查找文本 CTRL+R 在 当前窗口替换文本 CTRL+SHIFT+R 在指定窗口替换文本 ALT+SHIFT+C 查找修改的文件 CTRL+E 最近打开的文件 F3 向下查找关键字出现位置 SHIFT+F3 向上一个关键字出现位置 F4 查找变量来源 CTRL+ALT+F7 选中的字符查找工程出现的地方 CTRL+SHIFT+O 弹出显示查找内容 ALT+F1 查找文件所在目录位置 CTRL+H 显示类结构图 CTRL+Q 显示注释文档 CTRL+SHIFT+I 简短查看源定义 CTRL+SHIFT+P 查看表达式类型（在表达式上或者表达式末尾使用） 2、自动代码 Alt+Enter 导入包,自动修正 CTRL+ALT+L 格式化代码 CTRL+ALT+I 自动缩进 CTRL+ALT+O 优化导入的类和包 ALT+INSERT 生成代码(如GET,SET方法,构造函数等) CTRL+SHIFT+SPACE 自动补全代码 CTRL+空格 代码提示 CTRL+ALT+SPACE 类名或接口名提示 CTRL+P 方法参数提示 CTRL+J 自动代码 CTRL+ALT+T 把选中的代码放在 TRY{} IF{} ELSE{} 里 SHIFT+F6 重构-重命名 CTRL+I 实现接口 CTRL+SHIFT+Space 智能类型推断式返回（return关键字后使用） CTRL+ALT+V 自动生成表达式返回值 CTRL+ALT+M 重构表达式为函数(光标在表达式末尾) CTRL+Space 快速返回实现（return关键字后使用） 3、复制快捷方式 CTRL+D 复制行 CTRL+X 剪切,删除行 4、其他快捷方式 CIRL+U 大小写切换 CTRL+Z 倒退 CTRL+SHIFT+Z 向前 CTRL+ALT+F12 资源管理器打开文件夹 SHIFT+ALT+INSERT 竖编辑模式 Ctrl+/ 将当前行代码注释或取消注释 Ctrl+Shift+/ 在当前光标位置添加/**/或将/*xxxx*/内容取消注释 CTRL+W 选中代码，连续按会有其他效果 ALT+ ←/→ 切换代码视图 CTRL+ALT ←/→ 返回上次编辑的位置 ALT+ ↑/↓ 在方法间快速移动定位 ALT+1 快速打开或隐藏工程面板 CTRL+SHIFT+UP/DOWN 代码向上/下移动。 CTRL+UP/DOWN 光标跳转到第一行或最后一行下 ESC 光标返回编辑框 SHIFT+ESC 光标返回编辑框,关闭无用的窗口 ALT+J 相同单词多选 CTRL+SHIFT+A 工具调用 Ctrl+PageUp/PageDown 光标跳转到第一行或最后一行 By xiaobei，使用知识共享 署名-相同方式共享 4.0协议发布            此页面修订于： 2020-08-15 09:39:51 "},"book/technology/gitbook/命令及使用.html":{"url":"book/technology/gitbook/命令及使用.html","title":"命令及使用","keywords":"","body":"gitbook 操作命令 命令 npm install gitbook-cli -g gitbook -V gitbook install gitbook build gitbook pdf ./ ./mybook.pdf 生成 pdf 的前提环境 1.下载calibre,地址： https://calibre-ebook.com/ 2.把安装地址存入path内 By xiaobei，使用知识共享 署名-相同方式共享 4.0协议发布            此页面修订于： 2020-08-15 09:39:51 "},"book/technology/gitbook/vscode+picgo+github搭建markdown图床.html":{"url":"book/technology/gitbook/vscode+picgo+github搭建markdown图床.html","title":"vscode+picgo+github 搭建 markdown 图床","keywords":"","body":"vscode+picgo+github 搭建 markdown 图床 vscode 作为轻量级 IDE 神器，在安装 Markdown All in One 作为 markdown 编辑器异常好用，唯一美中不足的是不能上传图片。 这里就要讲到图床插件 picgo picgo 介绍 (github地址) You can change all the shortcuts below as you wish. OS Uploading an image from clipboard Uploading images from explorer Uploading an image from input box Windows/Unix Ctrl + Alt + U Ctrl + Alt + E Ctrl + Alt + O OsX Cmd + Opt + U Cmd + Opt + E Cmd + Opt + O 特性 Uploading an image from clipboard Uploading images from explorer Uploading images from input box Use selection text as the uploaded Notice: These characters: \\$, :, /, ? and newline will be ignored in the image name. (Because they are invalid for file names.) github 图床优点 稳定，用到微软破产应该不是问题 不花钱，这点很赞 容量大，一个仓库的上限是 100G，用作图床是够用了 用了 cdn 加速之后速度还是可以的 github 图床设置 注册登录 Github 略 创建public仓库 略 进入个人设置，选择开发者设置 settings-->Developer settings-->Personal access tokens,生成新的 token 添加描述，勾选 repo 保存生成的 token 关闭页面将无法再次看到 picgo 配置 GitHub 设置完之后，需要修改 vscode 的 picgo 插件的设置，配置刚才设置的 github 图床，具体设置如下： vscode 右下角或者 ctrl+，唤出设置页面 在扩展打开或者搜索 picgo 具体设置如图 配置说明： current选择 GitHub Branch为仓库的分支，默认为 master custom url 为图片上传的连接，有多种方式可以使用，我们这里用的是 cdn 加速方式 格式为https://cdn.jsdelivr.net/gh/[用户名]/[仓库名]@[分支名] 本文https://cdn.jsdelivr.net/gh/xiaobei930/PicBed@master path为图片存储在仓库中的路径，比如我的是 learningNotes/pictures/ 设置好后就可以愉快的在 vscode 里插图片了！ By xiaobei，使用知识共享 署名-相同方式共享 4.0协议发布            此页面修订于： 2020-08-15 09:39:51 "},"book/technology/database/redis总结.html":{"url":"book/technology/database/redis总结.html","title":"redis 总结","keywords":"","body":"redis 总结 来源 | 网络 Redis 简介 Redis 是完全开源免费的，遵守 BSD 协议，是一个高性能的 key - value 数据库 Redis 与 其他 key - value 缓存产品有以下三个特点： Redis 支持数据持久化，可以将内存中的数据保存在磁盘中，重启的时候可以再次加载进行使用。 Redis 不仅仅支持简单的 key - value 类型的数据，同时还提供 list，set，zset，hash 等数据结构的存储 Redis 支持数据的备份，即 master - slave 模式的数据备份 Redis 优势 性能极高 – Redis 读的速度是 110000 次 /s, 写的速度是 81000 次 /s 。 丰富的数据类型 - Redis 支持二进制案例的 Strings, Lists, Hashes, Sets 及 Ordered Sets 数据类型操作。 原子性 - Redis 的所有操作都是原子性的，意思就是要么成功执行要么失败完全不执行。单个操作是原子性的。多个操作也支持事务，即原子性，通过 MULTI 和 EXEC 指令包起来。 其他特性 - Redis 还支持 publish/subscribe 通知，key 过期等特性。 Redis 数据类型 Redis 支持 5 中数据类型：string（字符串），hash（哈希），list（列表），set（集合），zset（sorted set：有序集合） string string 是 redis 最基本的数据类型。一个 key 对应一个 value。 string 是二进制安全的。也就是说 redis 的 string 可以包含任何数据。比如 jpg 图片或者序列化的对象。 string 类型是 redis 最基本的数据类型，string 类型的值最大能存储 512 MB。 理解：string 就像是 java 中的 map 一样，一个 key 对应一个 value 127.0.0.1:6379> set hello world OK 127.0.0.1:6379> get hello \"world\" hash Redis hash 是一个键值对（key - value）集合。 Redis hash 是一个 string 类型的 key 和 value 的映射表，hash 特别适合用于存储对象。 **理解：可以将 hash 看成一个 key - value 的集合。也可以将其想成一个 hash 对应着多个 string。 与 string 区别：string 是 一个 key - value 键值对，而 hash 是多个 key - value 键值对。** // hash-key 可以看成是一个键值对集合的名字,在这里分别为其添加了 sub-key1 : value1、sub-key2 : value2、sub-key3 : value3 这三个键值对 127.0.0.1:6379> hset hash-key sub-key1 value1 (integer) 1 127.0.0.1:6379> hset hash-key sub-key2 value2 (integer) 1 127.0.0.1:6379> hset hash-key sub-key3 value3 (integer) 1 // 获取 hash-key 这个 hash 里面的所有键值对 127.0.0.1:6379> hgetall hash-key 1) \"sub-key1\" 2) \"value1\" 3) \"sub-key2\" 4) \"value2\" 5) \"sub-key3\" 6) \"value3\" // 删除 hash-key 这个 hash 里面的 sub-key2 键值对 127.0.0.1:6379> hdel hash-key sub-key2 (integer) 1 127.0.0.1:6379> hget hash-key sub-key2 (nil) 127.0.0.1:6379> hget hash-key sub-key1 \"value1\" 127.0.0.1:6379> hgetall hash-key 1) \"sub-key1\" 2) \"value1\" 3) \"sub-key3\" 4) \"value3\" list Redis 列表是简单的字符串列表，按照插入顺序排序。我们可以网列表的左边或者右边添加元素。 127.0.0.1:6379> rpush list-key v1 (integer) 1 127.0.0.1:6379> rpush list-key v2 (integer) 2 127.0.0.1:6379> rpush list-key v1 (integer) 3 127.0.0.1:6379> lrange list-key 0 -1 1) \"v1\" 2) \"v2\" 3) \"v1\" 127.0.0.1:6379> lindex list-key 1 \"v2\" 127.0.0.1:6379> lpop list (nil) 127.0.0.1:6379> lpop list-key \"v1\" 127.0.0.1:6379> lrange list-key 0 -1 1) \"v2\" 2) \"v1\" 我们可以看出 list 就是一个简单的字符串集合，和 Java 中的 list 相差不大，区别就是这里的 list 存放的是字符串。list 内的元素是可重复的。 set redis 的 set 是字符串类型的无序集合。集合是通过哈希表实现的，因此添加、删除、查找的复杂度都是 O（1）。 127.0.0.1:6379> sadd k1 v1 (integer) 1 127.0.0.1:6379> sadd k1 v2 (integer) 1 127.0.0.1:6379> sadd k1 v3 (integer) 1 127.0.0.1:6379> sadd k1 v1 (integer) 0 127.0.0.1:6379> smembers k1 1) \"v3\" 2) \"v2\" 3) \"v1\" 127.0.0.1:6379> 127.0.0.1:6379> sismember k1 k4 (integer) 0 127.0.0.1:6379> sismember k1 v1 (integer) 1 127.0.0.1:6379> srem k1 v2 (integer) 1 127.0.0.1:6379> srem k1 v2 (integer) 0 127.0.0.1:6379> smembers k1 1) \"v3\" 2) \"v1\" redis 的 set 与 java 中的 set 还是有点区别的。 redis 的 set 是一个 key 对应着 多个字符串类型的 value，也是一个字符串类型的集合，但是和 redis 的 list 不同的是 set 中的字符串集合元素不能重复，但是 list 可以。 Zset redis zset 和 set 一样都是 字符串类型元素的集合，并且集合内的元素不能重复。 不同的是 zset 每个元素都会关联一个 double 类型的分数。 redis 通过分数来为集合中的成员进行从小到大的排序。 zset 的元素是唯一的，但是分数（score）却可以重复。 127.0.0.1:6379> zadd zset-key 728 member1 (integer) 1 127.0.0.1:6379> zadd zset-key 982 member0 (integer) 1 127.0.0.1:6379> zadd zset-key 982 member0 (integer) 0 127.0.0.1:6379> zrange zset-key 0 -1 withscores 1) \"member1\" 2) \"728\" 3) \"member0\" 4) \"982\" 127.0.0.1:6379> zrangebyscore zset-key 0 800 withscores 1) \"member1\" 2) \"728\" 127.0.0.1:6379> zrem zset-key member1 (integer) 1 127.0.0.1:6379> zrem zset-key member1 (integer) 0 127.0.0.1:6379> zrange zset-key 0 -1 withscores 1) \"member0\" 2) \"982\" zset 是按照 分输的大小来排序的。 小总结 类型简介特性场景 string（字符串）二进制安全可以包含任何数据，比如 jpg 图片或者序列化的对象，一个键最大能存储 521M---Hash（哈希）键值对集合，即编程语言中的 Map 类型适合存储对象，并且可以像数据库中 update 一样只修改某一项属性值存储、读取、修改用户属性 List（列表）双向链表增删快，提供了操作某一段元素的 API 1、最新消息排行等功能（朋友圈的时间线） 2、消息队列 Set（集合）哈希表实现，元素不能重复添加删除查找的复杂度都是 O(1);为集合提供了求交集、并集、差集等操作共同好友；利用唯一性，统计访问网站的所有独立 ip；好友推荐时，根据 tag 求交集，大于某个阈值就可以推荐 Zset（有序集合）将 Set 中的元素增加一个权重参数 score，元素按 score 有序排列数据插入集合时，已经进行天然排序排行榜；带权重的消息队列 基本命令 自行查询 发布订阅 一般不用 Redis 做消息发布订阅。 简介 Redis 发布订阅 (pub/sub) 是一种消息通信模式：发送者 (pub) 发送消息，订阅者 (sub) 接收消息。 Redis 客户端可以订阅任意数量的频道。 下图展示了频道 channel1 ， 以及订阅这个频道的三个客户端 —— client2 、 client5 和 client1 之间的关系： 当有新消息通过 PUBLISH 命令发送给频道 channel1 时， 这个消息就会被发送给订阅它的三个客户端： 实例 以下实例演示了发布订阅是如何工作的。在我们实例中我们创建了订阅频道名为 redisChat: 127.0.0.1:6379> SUBsCRIBE redisChat Reading messages... (press Ctrl-C to quit) 1) \"subscribe\" 2) \"redisChat\" 现在，我们先重新开启个 redis 客户端，然后在同一个频道 redisChat 发布两次消息，订阅者就能接收到消息。 127.0.0.1:6379> PUBLISH redisChat \"send message\" (integer) 1 127.0.0.1:6379> PUBLISH redisChat \"hello world\" (integer) 1 # 订阅者的客户端显示如下 1) \"message\" 2) \"redisChat\" 3) \"send message\" 1) \"message\" 2) \"redisChat\" 3) \"hello world\" 发布订阅常用命令 自行查阅 事务 redis 事务一次可以执行多条命令，服务器在执行命令期间，不会去执行其他客户端的命令请求。 事务中的多条命令被一次性发送给服务器，而不是一条一条地发送，这种方式被称为流水线，它可以减少客户端与服务器之间的网络通信次数从而提升性能。 Redis 最简单的事务实现方式是使用 MULTI 和 EXEC 命令将事务操作包围起来。 批量操作在发送 EXEC 命令前被放入队列缓存。 收到 EXEC 命令后进入事务执行，事务中任意命令执行失败，其余命令依然被执行。也就是说 Redis 事务不保证原子性。 在事务执行过程中，其他客户端提交的命令请求不会插入到事务执行命令序列中。 一个事务从开始到执行会经历以下三个阶段： 开始事务。 命令入队。 执行事务。 实例 以下是一个事务的例子， 它先以 MULTI 开始一个事务， 然后将多个命令入队到事务中， 最后由 EXEC 命令触发事务， 一并执行事务中的所有命令： redis 127.0.0.1:6379> MULTI OK redis 127.0.0.1:6379> SET book-name \"Mastering C++ in 21 days\" QUEUED redis 127.0.0.1:6379> GET book-name QUEUED redis 127.0.0.1:6379> SADD tag \"C++\" \"Programming\" \"Mastering Series\" QUEUED redis 127.0.0.1:6379> SMEMBERS tag QUEUED redis 127.0.0.1:6379> EXEC 1) OK 2) \"Mastering C++ in 21 days\" 3) (integer) 3 4) 1) \"Mastering Series\" 1) \"C++\" 2) \"Programming\" 单个 Redis 命令的执行是原子性的，但 Redis 没有在事务上增加任何维持原子性的机制，所以 Redis 事务的执行并不是原子性的。 事务可以理解为一个打包的批量执行脚本，但批量指令并非原子化的操作，中间某条指令的失败不会导致前面已做指令的回滚，也不会造成后续的指令不做。 这是官网上的说明 From redis docs on transactions: It's important to note that even when a command fails, all the other commands in the queue are processed – Redis will not stop the processing of commands. 比如： redis 127.0.0.1:7000> multi OK redis 127.0.0.1:7000> set a aaa QUEUED redis 127.0.0.1:7000> set b bbb QUEUED redis 127.0.0.1:7000> set c ccc QUEUED redis 127.0.0.1:7000> exec 1) OK 2) OK 3) OK 如果在 set b bbb 处失败，set a 已成功不会回滚，set c 还会继续执行。 Redis 事务命令 下表列出了 redis 事务的相关命令： 序号|命令|描述 --|--|--| 1| DISCARD| 取消事务，放弃执行事务块内的所有命令| 2|EXEC|执行所有事务块内的命令| 3| MULTI| 标记一个事务块的开始| 4| UNWATCH |取消 WATCH 命令对所有 key 的监视| 5|WATCH key| [key …]监视一个 (或多个) key ，如果在事务执行之前这个 (或这些) key 被其他命令所改动，那么事务将被打断| 持久化 Redis 是内存型数据库，为了保证数据在断电后不会丢失，需要将内存中的数据持久化到硬盘上。 RDB 持久化 将某个时间点的所有数据都存放到硬盘上。 可以将快照复制到其他服务器从而创建具有相同数据的服务器副本。 如果系统发生故障，将会丢失最后一次创建快照之后的数据。 如果数据量大，保存快照的时间会很长。 AOF 持久化 将写命令添加到 AOF 文件（append only file）末尾。 使用 AOF 持久化需要设置同步选项，从而确保写命令同步到磁盘文件上的时机。这是因为对文件进行写入并不会马上将内容同步到磁盘上，而是先存储到缓冲区，然后由操作系统决定什么时候同步到磁盘。 选项同步频率 always 每个写命令都同步 eyerysec 每秒同步一次 no 让操作系统来决定何时同步 always 选项会严重减低服务器的性能 everysec 选项比较合适，可以保证系统崩溃时只会丢失一秒左右的数据，并且 Redis 每秒执行一次同步对服务器几乎没有任何影响。 no 选项并不能给服务器性能带来多大的提升，而且会增加系统崩溃时数据丢失的数量。 随着服务器写请求的增多，AOF 文件会越来越大。Redis 提供了一种将 AOF 重写的特性，能够去除 AOF 文件中的冗余写命令。 复制 通过使用 slaveof host port 命令来让一个服务器成为另一个服务器的从服务器。 一个从服务器只能有一个主服务器，并且不支持主主复制。 连接过程 主服务器创建快照文件，即 RDB 文件，发送给从服务器，并在发送期间使用缓冲区记录执行的写命令。快照文件发送完毕之后，开始像从服务器发送存储在缓冲区的写命令。 从服务器丢弃所有旧数据，载入主服务器发来的快照文件，之后从服务器开始接受主服务器发来的写命令。 主服务器每执行一次写命令，就向从服务器发送相同的写命令。 主从链 随着负载不断上升，主服务器无法很快的更新所有从服务器，或者重新连接和重新同步从服务器将导致系统超载。为了解决这个问题，可以创建一个中间层来分担主服务器的复制工作。中间层的服务器是最上层服务器的从服务器，又是最下层服务器的主服务器。 哨兵 Sentinel（哨兵）可以监听集群中的服务器，并在主服务器进入下线状态时，自动从从服务器中选举处新的主服务器。 分片 分片是将数据划分为多个部分的方法，可以将数据存储到多台机器里面，这种方法在解决某些问题时可以获得线性级别的性能提升。 假设有 4 个 Redis 实例 R0, R1, R2, R3, 还有很多表示用户的键 user:1, user:2, ... , 有不同的方式来选择一个指定的键存储在哪个实例中。 最简单的是范围分片，例如用户 id 从 0 ~ 1000 的存储到实例 R0 中，用户 id 从 1001 ~ 2000 的存储到实例 R1 中，等等。但是这样需要维护一张映射范围表，维护操作代价高。 还有一种是哈希分片。使用 CRC32 哈希函数将键转换为一个数字，再对实例数量求模就能知道存储的实例。 根据执行分片的位置，可以分为三种分片方式： 客户端分片：客户端使用一致性哈希等算法决定应当分布到哪个节点。 代理分片：将客户端的请求发送到代理上，由代理转发到正确的节点上。 服务器分片：Redis Cluster。 By xiaobei，使用知识共享 署名-相同方式共享 4.0协议发布            此页面修订于： 2020-08-15 09:39:51 "},"./":{"url":"./","title":"关于","keywords":"","body":"听小北瞎扯淡 各类学习笔记、心得、文章整理,包含接触过的各种乱七八糟的东西... 更新比较慢，随心情和时间 By xiaobei，使用知识共享 署名-相同方式共享 4.0协议发布            此页面修订于： 2020-08-15 09:39:51 "},"GLOSSARY.html":{"url":"GLOSSARY.html","keywords":"","body":"词汇表 词汇名称 词汇描述内容 By xiaobei，使用知识共享 署名-相同方式共享 4.0协议发布            此页面修订于： 2020-08-15 09:39:51 "}}